{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n  return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n  return Boolean(body && typeof body.getReader === \"function\" && typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n  // File objects count as a type of Blob, so we want to use instanceof explicitly\n  return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n  /**\n   * Makes a request over an underlying transport layer and returns the response.\n   * @param request - The request to be made.\n   */\n  sendRequest(request) {\n    return _asyncToGenerator(function* () {\n      const url = new URL(request.url);\n      const isInsecure = url.protocol !== \"https:\";\n      if (isInsecure && !request.allowInsecureConnection) {\n        throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n      }\n      if (request.proxySettings) {\n        throw new Error(\"HTTP proxy is not supported in browser environment\");\n      }\n      try {\n        return yield makeRequest(request);\n      } catch (e) {\n        throw getError(e, request);\n      }\n    })();\n  }\n}\n/**\n * Sends a request\n */\nfunction makeRequest(_x) {\n  return _makeRequest.apply(this, arguments);\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nfunction _makeRequest() {\n  _makeRequest = _asyncToGenerator(function* (request) {\n    const {\n      abortController,\n      abortControllerCleanup\n    } = setupAbortSignal(request);\n    try {\n      const headers = buildFetchHeaders(request.headers);\n      const requestBody = buildRequestBody(request);\n      /**\n       * Developers of the future:\n       * Do not set redirect: \"manual\" as part\n       * of request options.\n       * It will not work as you expect.\n       */\n      const response = yield fetch(request.url, {\n        body: requestBody,\n        method: request.method,\n        headers: headers,\n        signal: abortController.signal,\n        credentials: request.withCredentials ? \"include\" : \"same-origin\",\n        cache: \"no-store\"\n      });\n      // If we're uploading a blob, we need to fire the progress event manually\n      if (isBlob(request.body) && request.onUploadProgress) {\n        request.onUploadProgress({\n          loadedBytes: request.body.size\n        });\n      }\n      return buildPipelineResponse(response, request);\n    } finally {\n      if (abortControllerCleanup) {\n        abortControllerCleanup();\n      }\n    }\n  });\n  return _makeRequest.apply(this, arguments);\n}\nfunction buildPipelineResponse(_x2, _x3) {\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction _buildPipelineResponse() {\n  _buildPipelineResponse = _asyncToGenerator(function* (httpResponse, request) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n      request,\n      headers,\n      status: httpResponse.status\n    };\n    const bodyStream = isReadableStream(httpResponse.body) ? buildBodyStream(httpResponse.body, request.onDownloadProgress) : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) || ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n      if (request.enableBrowserStreams) {\n        response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n      } else {\n        const responseStream = new Response(bodyStream);\n        response.blobBody = responseStream.blob();\n      }\n    } else {\n      const responseStream = new Response(bodyStream);\n      response.bodyAsText = yield responseStream.text();\n    }\n    return response;\n  });\n  return _buildPipelineResponse.apply(this, arguments);\n}\nfunction setupAbortSignal(request) {\n  const abortController = new AbortController();\n  // Cleanup function\n  let abortControllerCleanup;\n  /**\n   * Attach an abort listener to the request\n   */\n  let abortListener;\n  if (request.abortSignal) {\n    if (request.abortSignal.aborted) {\n      throw new AbortError(\"The operation was aborted.\");\n    }\n    abortListener = event => {\n      if (event.type === \"abort\") {\n        abortController.abort();\n      }\n    };\n    request.abortSignal.addEventListener(\"abort\", abortListener);\n    abortControllerCleanup = () => {\n      var _a;\n      if (abortListener) {\n        (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n      }\n    };\n  }\n  // If a timeout was passed, call the abort signal once the time elapses\n  if (request.timeout > 0) {\n    setTimeout(() => {\n      abortController.abort();\n    }, request.timeout);\n  }\n  return {\n    abortController,\n    abortControllerCleanup\n  };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n  var _a;\n  if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n    return e;\n  } else {\n    return new RestError(`Error sending request: ${e.message}`, {\n      code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n      request\n    });\n  }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n  const headers = new Headers();\n  for (const [name, value] of pipelineHeaders) {\n    headers.append(name, value);\n  }\n  return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n  const responseHeaders = createHttpHeaders();\n  for (const [name, value] of httpResponse.headers) {\n    responseHeaders.set(name, value);\n  }\n  return responseHeaders;\n}\nfunction buildRequestBody(request) {\n  const body = typeof request.body === \"function\" ? request.body() : request.body;\n  if (isNodeReadableStream(body)) {\n    throw new Error(\"Node streams are not supported in browser environment.\");\n  }\n  return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n  let loadedBytes = 0;\n  // If the current browser supports pipeThrough we use a TransformStream\n  // to report progress\n  if (isTransformStreamSupported(readableStream)) {\n    return readableStream.pipeThrough(new TransformStream({\n      transform(chunk, controller) {\n        if (chunk === null) {\n          controller.terminate();\n          return;\n        }\n        controller.enqueue(chunk);\n        loadedBytes += chunk.length;\n        if (onProgress) {\n          onProgress({\n            loadedBytes\n          });\n        }\n      }\n    }));\n  } else {\n    // If we can't use transform streams, wrap the original stream in a new readable stream\n    // and use pull to enqueue each chunk and report progress.\n    const reader = readableStream.getReader();\n    return new ReadableStream({\n      pull(controller) {\n        return _asyncToGenerator(function* () {\n          var _a;\n          const {\n            done,\n            value\n          } = yield reader.read();\n          // When no more data needs to be consumed, break the reading\n          if (done || !value) {\n            // Close the stream\n            controller.close();\n            reader.releaseLock();\n            return;\n          }\n          loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n          // Enqueue the next data chunk into our target stream\n          controller.enqueue(value);\n          if (onProgress) {\n            onProgress({\n              loadedBytes\n            });\n          }\n        })();\n      }\n    });\n  }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n  return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n  return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}","map":{"version":3,"names":["AbortError","RestError","createHttpHeaders","isNodeReadableStream","body","pipe","isReadableStream","Boolean","getReader","tee","isBlob","Blob","FetchHttpClient","sendRequest","request","_asyncToGenerator","url","URL","isInsecure","protocol","allowInsecureConnection","Error","proxySettings","makeRequest","e","getError","_x","_makeRequest","apply","arguments","abortController","abortControllerCleanup","setupAbortSignal","headers","buildFetchHeaders","requestBody","buildRequestBody","response","fetch","method","signal","credentials","withCredentials","cache","onUploadProgress","loadedBytes","size","buildPipelineResponse","_x2","_x3","_buildPipelineResponse","httpResponse","_a","_b","buildPipelineHeaders","status","bodyStream","buildBodyStream","onDownloadProgress","streamResponseStatusCodes","has","Number","POSITIVE_INFINITY","enableBrowserStreams","browserStreamBody","undefined","responseStream","Response","blobBody","blob","bodyAsText","text","AbortController","abortListener","abortSignal","aborted","event","type","abort","addEventListener","removeEventListener","timeout","setTimeout","name","message","code","REQUEST_SEND_ERROR","pipelineHeaders","Headers","value","append","responseHeaders","set","readableStream","onProgress","isTransformStreamSupported","pipeThrough","TransformStream","transform","chunk","controller","terminate","enqueue","length","reader","ReadableStream","pull","done","read","close","releaseLock","createFetchHttpClient","self"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/core-rest-pipeline/dist-esm/src/fetchHttpClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AbortError } from \"@azure/abort-controller\";\nimport { RestError } from \"./restError\";\nimport { createHttpHeaders } from \"./httpHeaders\";\n/**\n * Checks if the body is a NodeReadable stream which is not supported in Browsers\n */\nfunction isNodeReadableStream(body) {\n    return body && typeof body.pipe === \"function\";\n}\n/**\n * Checks if the body is a ReadableStream supported by browsers\n */\nfunction isReadableStream(body) {\n    return Boolean(body &&\n        typeof body.getReader === \"function\" &&\n        typeof body.tee === \"function\");\n}\n/**\n * Checks if the body is a Blob or Blob-like\n */\nfunction isBlob(body) {\n    // File objects count as a type of Blob, so we want to use instanceof explicitly\n    return (typeof Blob === \"function\" || typeof Blob === \"object\") && body instanceof Blob;\n}\n/**\n * A HttpClient implementation that uses window.fetch to send HTTP requests.\n * @internal\n */\nclass FetchHttpClient {\n    /**\n     * Makes a request over an underlying transport layer and returns the response.\n     * @param request - The request to be made.\n     */\n    async sendRequest(request) {\n        const url = new URL(request.url);\n        const isInsecure = url.protocol !== \"https:\";\n        if (isInsecure && !request.allowInsecureConnection) {\n            throw new Error(`Cannot connect to ${request.url} while allowInsecureConnection is false.`);\n        }\n        if (request.proxySettings) {\n            throw new Error(\"HTTP proxy is not supported in browser environment\");\n        }\n        try {\n            return await makeRequest(request);\n        }\n        catch (e) {\n            throw getError(e, request);\n        }\n    }\n}\n/**\n * Sends a request\n */\nasync function makeRequest(request) {\n    const { abortController, abortControllerCleanup } = setupAbortSignal(request);\n    try {\n        const headers = buildFetchHeaders(request.headers);\n        const requestBody = buildRequestBody(request);\n        /**\n         * Developers of the future:\n         * Do not set redirect: \"manual\" as part\n         * of request options.\n         * It will not work as you expect.\n         */\n        const response = await fetch(request.url, {\n            body: requestBody,\n            method: request.method,\n            headers: headers,\n            signal: abortController.signal,\n            credentials: request.withCredentials ? \"include\" : \"same-origin\",\n            cache: \"no-store\",\n        });\n        // If we're uploading a blob, we need to fire the progress event manually\n        if (isBlob(request.body) && request.onUploadProgress) {\n            request.onUploadProgress({ loadedBytes: request.body.size });\n        }\n        return buildPipelineResponse(response, request);\n    }\n    finally {\n        if (abortControllerCleanup) {\n            abortControllerCleanup();\n        }\n    }\n}\n/**\n * Creates a pipeline response from a Fetch response;\n */\nasync function buildPipelineResponse(httpResponse, request) {\n    var _a, _b;\n    const headers = buildPipelineHeaders(httpResponse);\n    const response = {\n        request,\n        headers,\n        status: httpResponse.status,\n    };\n    const bodyStream = isReadableStream(httpResponse.body)\n        ? buildBodyStream(httpResponse.body, request.onDownloadProgress)\n        : httpResponse.body;\n    if (\n    // Value of POSITIVE_INFINITY in streamResponseStatusCodes is considered as any status code\n    ((_a = request.streamResponseStatusCodes) === null || _a === void 0 ? void 0 : _a.has(Number.POSITIVE_INFINITY)) ||\n        ((_b = request.streamResponseStatusCodes) === null || _b === void 0 ? void 0 : _b.has(response.status))) {\n        if (request.enableBrowserStreams) {\n            response.browserStreamBody = bodyStream !== null && bodyStream !== void 0 ? bodyStream : undefined;\n        }\n        else {\n            const responseStream = new Response(bodyStream);\n            response.blobBody = responseStream.blob();\n        }\n    }\n    else {\n        const responseStream = new Response(bodyStream);\n        response.bodyAsText = await responseStream.text();\n    }\n    return response;\n}\nfunction setupAbortSignal(request) {\n    const abortController = new AbortController();\n    // Cleanup function\n    let abortControllerCleanup;\n    /**\n     * Attach an abort listener to the request\n     */\n    let abortListener;\n    if (request.abortSignal) {\n        if (request.abortSignal.aborted) {\n            throw new AbortError(\"The operation was aborted.\");\n        }\n        abortListener = (event) => {\n            if (event.type === \"abort\") {\n                abortController.abort();\n            }\n        };\n        request.abortSignal.addEventListener(\"abort\", abortListener);\n        abortControllerCleanup = () => {\n            var _a;\n            if (abortListener) {\n                (_a = request.abortSignal) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"abort\", abortListener);\n            }\n        };\n    }\n    // If a timeout was passed, call the abort signal once the time elapses\n    if (request.timeout > 0) {\n        setTimeout(() => {\n            abortController.abort();\n        }, request.timeout);\n    }\n    return { abortController, abortControllerCleanup };\n}\n/**\n * Gets the specific error\n */\nfunction getError(e, request) {\n    var _a;\n    if (e && (e === null || e === void 0 ? void 0 : e.name) === \"AbortError\") {\n        return e;\n    }\n    else {\n        return new RestError(`Error sending request: ${e.message}`, {\n            code: (_a = e === null || e === void 0 ? void 0 : e.code) !== null && _a !== void 0 ? _a : RestError.REQUEST_SEND_ERROR,\n            request,\n        });\n    }\n}\n/**\n * Converts PipelineRequest headers to Fetch headers\n */\nfunction buildFetchHeaders(pipelineHeaders) {\n    const headers = new Headers();\n    for (const [name, value] of pipelineHeaders) {\n        headers.append(name, value);\n    }\n    return headers;\n}\nfunction buildPipelineHeaders(httpResponse) {\n    const responseHeaders = createHttpHeaders();\n    for (const [name, value] of httpResponse.headers) {\n        responseHeaders.set(name, value);\n    }\n    return responseHeaders;\n}\nfunction buildRequestBody(request) {\n    const body = typeof request.body === \"function\" ? request.body() : request.body;\n    if (isNodeReadableStream(body)) {\n        throw new Error(\"Node streams are not supported in browser environment.\");\n    }\n    return isReadableStream(body) ? buildBodyStream(body, request.onUploadProgress) : body;\n}\n/**\n * Reads the request/response original stream and stream it through a new\n * ReadableStream, this is done to be able to report progress in a way that\n * all modern browsers support. TransformStreams would be an alternative,\n * however they are not yet supported by all browsers i.e Firefox\n */\nfunction buildBodyStream(readableStream, onProgress) {\n    let loadedBytes = 0;\n    // If the current browser supports pipeThrough we use a TransformStream\n    // to report progress\n    if (isTransformStreamSupported(readableStream)) {\n        return readableStream.pipeThrough(new TransformStream({\n            transform(chunk, controller) {\n                if (chunk === null) {\n                    controller.terminate();\n                    return;\n                }\n                controller.enqueue(chunk);\n                loadedBytes += chunk.length;\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        }));\n    }\n    else {\n        // If we can't use transform streams, wrap the original stream in a new readable stream\n        // and use pull to enqueue each chunk and report progress.\n        const reader = readableStream.getReader();\n        return new ReadableStream({\n            async pull(controller) {\n                var _a;\n                const { done, value } = await reader.read();\n                // When no more data needs to be consumed, break the reading\n                if (done || !value) {\n                    // Close the stream\n                    controller.close();\n                    reader.releaseLock();\n                    return;\n                }\n                loadedBytes += (_a = value === null || value === void 0 ? void 0 : value.length) !== null && _a !== void 0 ? _a : 0;\n                // Enqueue the next data chunk into our target stream\n                controller.enqueue(value);\n                if (onProgress) {\n                    onProgress({ loadedBytes });\n                }\n            },\n        });\n    }\n}\n/**\n * Create a new HttpClient instance for the browser environment.\n * @internal\n */\nexport function createFetchHttpClient() {\n    return new FetchHttpClient();\n}\nfunction isTransformStreamSupported(readableStream) {\n    return readableStream.pipeThrough !== undefined && self.TransformStream !== undefined;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}