{"ast":null,"code":"/*! @azure/msal-common v13.1.0 2023-06-07 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Class that handles response parsing.\r\n */\nvar ResponseHandler = /** @class */function () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n    this.performanceClient = performanceClient;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    }\n    // Check for error\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\n      }\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\n      }\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\n              // token nonce check (TODO: Add a warning if no nonce is given?)\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              }\n              // token max_age check\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            }\n            // generate homeAccountId\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            }\n            // Add keyId from request to serverTokenResponse if defined\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _b.label = 1;\n          case 1:\n            _b.trys.push([1,, 5, 8]);\n            if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\n          case 2:\n            _b.sent();\n            _b.label = 3;\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n            return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\n          case 4:\n            _b.sent();\n            return [3 /*break*/, 8];\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\n          case 6:\n            _b.sent();\n            _b.label = 7;\n          case 7:\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    // IdToken: non AAD scenarios can have empty realm\n    var cachedIdToken;\n    var cachedAccount;\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\n    }\n    // AccessToken\n    var cachedAccessToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    var cachedRefreshToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    var cachedAppMetadata = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\n    // ADFS does not require client_info in the response\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    }\n    // This fallback applies to B2C as well as they fall under an AAD account type.\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3 /*break*/, 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n            return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\n          case 1:\n            accessToken = _e.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\n            // for hybrid + native bridge enablement, send back the native account Id\n            if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\n              cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\n            }\n            return [2 /*return*/, {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n  return ResponseHandler;\n}();\nexport { ResponseHandler };","map":{"version":3,"names":["__awaiter","__generator","buildClientInfo","ClientAuthError","StringUtils","ServerError","AuthToken","ScopeSet","AccountEntity","AuthorityType","IdTokenEntity","AccessTokenEntity","RefreshTokenEntity","InteractionRequiredAuthError","CacheRecord","ProtocolUtils","Constants","AuthenticationScheme","THE_FAMILY_ID","PopTokenGenerator","AppMetadataEntity","TokenCacheContext","PerformanceEvents","ResponseHandler","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","performanceClient","prototype","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","EMPTY_STRING","timestamp","trace_id","correlation_id","claims","client_info","validateTokenResponse","serverResponse","errString","error_codes","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","_a","idTokenObj","authTime","requestStateObj","cacheRecord","cacheContext","key","account","_b","label","addQueueMeasurement","HandleServerTokenResponse","id_token","isEmpty","nonce","createNonceMismatchError","maxAge","auth_time","createAuthTimeNotFoundError","checkMaxAge","homeAccountIdentifier","generateHomeAccountId","authorityType","parseRequestState","key_id","sshKid","undefined","generateCacheRecord","trys","push","verbose","beforeCacheAccess","sent","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","createRefreshTokenEntity","foci","cachedAppMetadata","createAppMetadataEntity","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","requestId","_c","accessToken","expiresOn","extExpiresOn","familyId","popTokenGenerator","_d","secret","keyId","uid","_e","tokenType","POP","createKeyIdMissingError","signPopToken","target","asArray","Date","Number","extendedExpiresOn","appMetadata","oid","sub","spa_accountid","nativeAccountId","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","correlationId","userRequestState","msGraphHost","code","spa_code","fromNativeBroker"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-browser/node_modules/@azure/msal-common/dist/response/ResponseHandler.js"],"sourcesContent":["/*! @azure/msal-common v13.1.0 2023-06-07 */\n'use strict';\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\nimport { PerformanceEvents } from '../telemetry/performance/PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nvar ResponseHandler = /** @class */ (function () {\r\n    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin, performanceClient) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n        this.performanceClient = performanceClient;\r\n    }\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror, serverResponseHash.timestamp || Constants.EMPTY_STRING, serverResponseHash.trace_id || Constants.EMPTY_STRING, serverResponseHash.correlation_id || Constants.EMPTY_STRING, serverResponseHash.claims || Constants.EMPTY_STRING);\r\n            }\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    };\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror, serverResponse.timestamp || Constants.EMPTY_STRING, serverResponse.trace_id || Constants.EMPTY_STRING, serverResponse.correlation_id || Constants.EMPTY_STRING, serverResponse.claims || Constants.EMPTY_STRING);\r\n            }\r\n            var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        (_a = this.performanceClient) === null || _a === void 0 ? void 0 : _a.addQueueMeasurement(PerformanceEvents.HandleServerTokenResponse, serverTokenResponse.correlation_id);\r\n                        if (serverTokenResponse.id_token) {\r\n                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n                            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                                    throw ClientAuthError.createNonceMismatchError();\r\n                                }\r\n                            }\r\n                            // token max_age check\r\n                            if (request.maxAge || (request.maxAge === 0)) {\r\n                                authTime = idTokenObj.claims.auth_time;\r\n                                if (!authTime) {\r\n                                    throw ClientAuthError.createAuthTimeNotFoundError();\r\n                                }\r\n                                AuthToken.checkMaxAge(authTime, request.maxAge);\r\n                            }\r\n                        }\r\n                        // generate homeAccountId\r\n                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n                        if (!!authCodePayload && !!authCodePayload.state) {\r\n                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n                        }\r\n                        // Add keyId from request to serverTokenResponse if defined\r\n                        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\r\n                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, , 5, 8]);\r\n                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                        cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\r\n                    case 2:\r\n                        _b.sent();\r\n                        _b.label = 3;\r\n                    case 3:\r\n                        /*\r\n                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n                         * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n                         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n                         */\r\n                        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\r\n                            key = cacheRecord.account.generateAccountKey();\r\n                            account = this.cacheStorage.getAccount(key);\r\n                            if (!account) {\r\n                                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\r\n                            }\r\n                        }\r\n                        return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\r\n                    case 4:\r\n                        _b.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 5:\r\n                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\r\n                        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\r\n                    case 6:\r\n                        _b.sent();\r\n                        _b.label = 7;\r\n                    case 7: return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse, serverRequestId)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\r\n        var env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        var cachedIdToken;\r\n        var cachedAccount;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\r\n            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\r\n        }\r\n        // AccessToken\r\n        var cachedAccessToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n            // If scopes not returned in server response, use request scopes\r\n            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            var tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\r\n        }\r\n        // refreshToken\r\n        var cachedRefreshToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\r\n        }\r\n        // appMetadata\r\n        var cachedAppMetadata = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    };\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\r\n        var authorityType = authority.authorityType;\r\n        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\r\n        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n        }\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n    };\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, serverTokenResponse, requestId) {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        accessToken = Constants.EMPTY_STRING;\r\n                        responseScopes = [];\r\n                        expiresOn = null;\r\n                        familyId = Constants.EMPTY_STRING;\r\n                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];\r\n                        if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\r\n                        popTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                        _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\r\n                        if (!keyId) {\r\n                            throw ClientAuthError.createKeyIdMissingError();\r\n                        }\r\n                        return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\r\n                    case 1:\r\n                        accessToken = _e.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        accessToken = cacheRecord.accessToken.secret;\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n                        _e.label = 4;\r\n                    case 4:\r\n                        if (cacheRecord.appMetadata) {\r\n                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n                        }\r\n                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\r\n                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\r\n                        // for hybrid + native bridge enablement, send back the native account Id\r\n                        if ((serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid) && !!cacheRecord.account) {\r\n                            cacheRecord.account.nativeAccountId = serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_accountid;\r\n                        }\r\n                        return [2 /*return*/, {\r\n                                authority: authority.canonicalAuthority,\r\n                                uniqueId: uid,\r\n                                tenantId: tid,\r\n                                scopes: responseScopes,\r\n                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n                                accessToken: accessToken,\r\n                                fromCache: fromTokenCache,\r\n                                expiresOn: expiresOn,\r\n                                correlationId: request.correlationId,\r\n                                requestId: requestId || Constants.EMPTY_STRING,\r\n                                extExpiresOn: extExpiresOn,\r\n                                familyId: familyId,\r\n                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\r\n                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\r\n                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\r\n                                code: serverTokenResponse === null || serverTokenResponse === void 0 ? void 0 : serverTokenResponse.spa_code,\r\n                                fromNativeBroker: false,\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ResponseHandler;\r\n}());\n\nexport { ResponseHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}