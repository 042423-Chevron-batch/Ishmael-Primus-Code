{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n  /**\n   * Creates an instance of ChainedTokenCredential using the given credentials.\n   *\n   * @param sources - `TokenCredential` implementations to be tried in order.\n   *\n   * Example usage:\n   * ```javascript\n   * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n   * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n   * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n   * ```\n   */\n  constructor(...sources) {\n    /**\n     * The message to use when the chained token fails to get a token\n     */\n    this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n    this._sources = [];\n    this._sources = sources;\n  }\n  /**\n   * Returns the first access token returned by one of the chained\n   * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n   * when one or more credentials throws an {@link AuthenticationError} and\n   * no credentials have returned an access token.\n   *\n   * This method is called automatically by Azure SDK client libraries. You may call this method\n   * directly, but you must also handle token caching and token refreshing.\n   *\n   * @param scopes - The list of scopes for which the token will have access.\n   * @param options - The options used to configure any requests this\n   *                `TokenCredential` implementation might make.\n   */\n  getToken(scopes, options = {}) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let token = null;\n      let successfulCredentialName = \"\";\n      const errors = [];\n      return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updatedOptions) {\n          for (let i = 0; i < _this._sources.length && token === null; i++) {\n            try {\n              token = yield _this._sources[i].getToken(scopes, updatedOptions);\n              successfulCredentialName = _this._sources[i].constructor.name;\n            } catch (err) {\n              if (err.name === \"CredentialUnavailableError\" || err.name === \"AuthenticationRequiredError\") {\n                errors.push(err);\n              } else {\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n              }\n            }\n          }\n          if (!token && errors.length > 0) {\n            const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n            logger.getToken.info(formatError(scopes, err));\n            throw err;\n          }\n          logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n          if (token === null) {\n            throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n          }\n          return token;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n}","map":{"version":3,"names":["AggregateAuthenticationError","CredentialUnavailableError","tracingClient","credentialLogger","formatError","formatSuccess","logger","ChainedTokenCredential","constructor","sources","UnavailableMessage","_sources","getToken","scopes","options","_this","_asyncToGenerator","token","successfulCredentialName","errors","withSpan","_ref","updatedOptions","i","length","name","err","push","info","_x","apply","arguments"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/identity/dist-esm/src/credentials/chainedTokenCredential.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AggregateAuthenticationError, CredentialUnavailableError } from \"../errors\";\nimport { tracingClient } from \"../util/tracing\";\nimport { credentialLogger, formatError, formatSuccess } from \"../util/logging\";\n/**\n * @internal\n */\nexport const logger = credentialLogger(\"ChainedTokenCredential\");\n/**\n * Enables multiple `TokenCredential` implementations to be tried in order\n * until one of the getToken methods returns an access token.\n */\nexport class ChainedTokenCredential {\n    /**\n     * Creates an instance of ChainedTokenCredential using the given credentials.\n     *\n     * @param sources - `TokenCredential` implementations to be tried in order.\n     *\n     * Example usage:\n     * ```javascript\n     * const firstCredential = new ClientSecretCredential(tenantId, clientId, clientSecret);\n     * const secondCredential = new ClientSecretCredential(tenantId, anotherClientId, anotherSecret);\n     * const credentialChain = new ChainedTokenCredential(firstCredential, secondCredential);\n     * ```\n     */\n    constructor(...sources) {\n        /**\n         * The message to use when the chained token fails to get a token\n         */\n        this.UnavailableMessage = \"ChainedTokenCredential => failed to retrieve a token from the included credentials\";\n        this._sources = [];\n        this._sources = sources;\n    }\n    /**\n     * Returns the first access token returned by one of the chained\n     * `TokenCredential` implementations.  Throws an {@link AggregateAuthenticationError}\n     * when one or more credentials throws an {@link AuthenticationError} and\n     * no credentials have returned an access token.\n     *\n     * This method is called automatically by Azure SDK client libraries. You may call this method\n     * directly, but you must also handle token caching and token refreshing.\n     *\n     * @param scopes - The list of scopes for which the token will have access.\n     * @param options - The options used to configure any requests this\n     *                `TokenCredential` implementation might make.\n     */\n    async getToken(scopes, options = {}) {\n        let token = null;\n        let successfulCredentialName = \"\";\n        const errors = [];\n        return tracingClient.withSpan(\"ChainedTokenCredential.getToken\", options, async (updatedOptions) => {\n            for (let i = 0; i < this._sources.length && token === null; i++) {\n                try {\n                    token = await this._sources[i].getToken(scopes, updatedOptions);\n                    successfulCredentialName = this._sources[i].constructor.name;\n                }\n                catch (err) {\n                    if (err.name === \"CredentialUnavailableError\" ||\n                        err.name === \"AuthenticationRequiredError\") {\n                        errors.push(err);\n                    }\n                    else {\n                        logger.getToken.info(formatError(scopes, err));\n                        throw err;\n                    }\n                }\n            }\n            if (!token && errors.length > 0) {\n                const err = new AggregateAuthenticationError(errors, \"ChainedTokenCredential authentication failed.\");\n                logger.getToken.info(formatError(scopes, err));\n                throw err;\n            }\n            logger.getToken.info(`Result for ${successfulCredentialName}: ${formatSuccess(scopes)}`);\n            if (token === null) {\n                throw new CredentialUnavailableError(\"Failed to retrieve a valid token\");\n            }\n            return token;\n        });\n    }\n}\n"],"mappings":";AAAA;AACA;AACA,SAASA,4BAA4B,EAAEC,0BAA0B,QAAQ,WAAW;AACpF,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,gBAAgB,EAAEC,WAAW,EAAEC,aAAa,QAAQ,iBAAiB;AAC9E;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAGH,gBAAgB,CAAC,wBAAwB,CAAC;AAChE;AACA;AACA;AACA;AACA,OAAO,MAAMI,sBAAsB,CAAC;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,WAAWA,CAAC,GAAGC,OAAO,EAAE;IACpB;AACR;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,oFAAoF;IAC9G,IAAI,CAACC,QAAQ,GAAG,EAAE;IAClB,IAAI,CAACA,QAAQ,GAAGF,OAAO;EAC3B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACUG,QAAQA,CAACC,MAAM,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MACjC,IAAIC,KAAK,GAAG,IAAI;MAChB,IAAIC,wBAAwB,GAAG,EAAE;MACjC,MAAMC,MAAM,GAAG,EAAE;MACjB,OAAOjB,aAAa,CAACkB,QAAQ,CAAC,iCAAiC,EAAEN,OAAO;QAAA,IAAAO,IAAA,GAAAL,iBAAA,CAAE,WAAOM,cAAc,EAAK;UAChG,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGR,KAAI,CAACJ,QAAQ,CAACa,MAAM,IAAIP,KAAK,KAAK,IAAI,EAAEM,CAAC,EAAE,EAAE;YAC7D,IAAI;cACAN,KAAK,SAASF,KAAI,CAACJ,QAAQ,CAACY,CAAC,CAAC,CAACX,QAAQ,CAACC,MAAM,EAAES,cAAc,CAAC;cAC/DJ,wBAAwB,GAAGH,KAAI,CAACJ,QAAQ,CAACY,CAAC,CAAC,CAACf,WAAW,CAACiB,IAAI;YAChE,CAAC,CACD,OAAOC,GAAG,EAAE;cACR,IAAIA,GAAG,CAACD,IAAI,KAAK,4BAA4B,IACzCC,GAAG,CAACD,IAAI,KAAK,6BAA6B,EAAE;gBAC5CN,MAAM,CAACQ,IAAI,CAACD,GAAG,CAAC;cACpB,CAAC,MACI;gBACDpB,MAAM,CAACM,QAAQ,CAACgB,IAAI,CAACxB,WAAW,CAACS,MAAM,EAAEa,GAAG,CAAC,CAAC;gBAC9C,MAAMA,GAAG;cACb;YACJ;UACJ;UACA,IAAI,CAACT,KAAK,IAAIE,MAAM,CAACK,MAAM,GAAG,CAAC,EAAE;YAC7B,MAAME,GAAG,GAAG,IAAI1B,4BAA4B,CAACmB,MAAM,EAAE,+CAA+C,CAAC;YACrGb,MAAM,CAACM,QAAQ,CAACgB,IAAI,CAACxB,WAAW,CAACS,MAAM,EAAEa,GAAG,CAAC,CAAC;YAC9C,MAAMA,GAAG;UACb;UACApB,MAAM,CAACM,QAAQ,CAACgB,IAAI,CAAE,cAAaV,wBAAyB,KAAIb,aAAa,CAACQ,MAAM,CAAE,EAAC,CAAC;UACxF,IAAII,KAAK,KAAK,IAAI,EAAE;YAChB,MAAM,IAAIhB,0BAA0B,CAAC,kCAAkC,CAAC;UAC5E;UACA,OAAOgB,KAAK;QAChB,CAAC;QAAA,iBAAAY,EAAA;UAAA,OAAAR,IAAA,CAAAS,KAAA,OAAAC,SAAA;QAAA;MAAA,IAAC;IAAC;EACP;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}