{"ast":null,"code":"// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as msalCommon from \"@azure/msal-common\";\nimport { isNode } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { formatError, formatSuccess } from \"../util/logging\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors\";\nimport { DefaultAuthorityHost, DefaultTenantId } from \"../constants\";\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, logger, msalToken, getTokenOptions) {\n  const error = message => {\n    logger.getToken.info(message);\n    return new AuthenticationRequiredError({\n      scopes: Array.isArray(scopes) ? scopes : [scopes],\n      getTokenOptions,\n      message\n    });\n  };\n  if (!msalToken) {\n    throw error(\"No response\");\n  }\n  if (!msalToken.expiresOn) {\n    throw error(`Response had no \"expiresOn\" property.`);\n  }\n  if (!msalToken.accessToken) {\n    throw error(`Response had no \"accessToken\" property.`);\n  }\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n  if (!host) {\n    host = DefaultAuthorityHost;\n  }\n  if (new RegExp(`${tenantId}/?$`).test(host)) {\n    return host;\n  }\n  if (host.endsWith(\"/\")) {\n    return host + tenantId;\n  } else {\n    return `${host}/${tenantId}`;\n  }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost) {\n  if (tenantId === \"adfs\" && authorityHost) {\n    return [authorityHost];\n  }\n  return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param logger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (logger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n  if (containsPii) {\n    return;\n  }\n  switch (level) {\n    case msalCommon.LogLevel.Error:\n      logger.info(`MSAL ${platform} V2 error: ${message}`);\n      return;\n    case msalCommon.LogLevel.Info:\n      logger.info(`MSAL ${platform} V2 info message: ${message}`);\n      return;\n    case msalCommon.LogLevel.Verbose:\n      logger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n      return;\n    case msalCommon.LogLevel.Warning:\n      logger.info(`MSAL ${platform} V2 warning: ${message}`);\n      return;\n  }\n};\n/**\n * The common utility functions for the MSAL clients.\n * Defined as a class so that the classes extending this one can have access to its methods and protected properties.\n *\n * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.\n *\n * @internal\n */\nexport class MsalBaseUtilities {\n  constructor(options) {\n    this.logger = options.logger;\n    this.account = options.authenticationRecord;\n  }\n  /**\n   * Generates a UUID\n   */\n  generateUuid() {\n    return uuidv4();\n  }\n  /**\n   * Handles the MSAL authentication result.\n   * If the result has an account, we update the local account reference.\n   * If the token received is invalid, an error will be thrown depending on what's missing.\n   */\n  handleResult(scopes, clientId, result, getTokenOptions) {\n    if (result === null || result === void 0 ? void 0 : result.account) {\n      this.account = msalToPublic(clientId, result.account);\n    }\n    ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);\n    this.logger.getToken.info(formatSuccess(scopes));\n    return {\n      token: result.accessToken,\n      expiresOnTimestamp: result.expiresOn.getTime()\n    };\n  }\n  /**\n   * Handles MSAL errors.\n   */\n  handleError(scopes, error, getTokenOptions) {\n    if (error.name === \"AuthError\" || error.name === \"ClientAuthError\" || error.name === \"BrowserAuthError\") {\n      const msalError = error;\n      switch (msalError.errorCode) {\n        case \"endpoints_resolution_error\":\n          this.logger.info(formatError(scopes, error.message));\n          return new CredentialUnavailableError(error.message);\n        case \"device_code_polling_cancelled\":\n          return new AbortError(\"The authentication has been aborted by the caller.\");\n        case \"consent_required\":\n        case \"interaction_required\":\n        case \"login_required\":\n          this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n          break;\n        default:\n          this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n          break;\n      }\n    }\n    if (error.name === \"ClientConfigurationError\" || error.name === \"BrowserConfigurationAuthError\" || error.name === \"AbortError\") {\n      return error;\n    }\n    return new AuthenticationRequiredError({\n      scopes,\n      getTokenOptions,\n      message: error.message\n    });\n  }\n}\n// transformations.ts\nexport function publicToMsal(account) {\n  const [environment] = account.authority.match(/([a-z]*\\.[a-z]*\\.[a-z]*)/) || [];\n  return Object.assign(Object.assign({}, account), {\n    localAccountId: account.homeAccountId,\n    environment\n  });\n}\nexport function msalToPublic(clientId, account) {\n  const record = {\n    authority: getAuthority(account.tenantId, account.environment),\n    homeAccountId: account.homeAccountId,\n    tenantId: account.tenantId || DefaultTenantId,\n    username: account.username,\n    clientId,\n    version: LatestAuthenticationRecordVersion\n  };\n  return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n  return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n  const parsed = JSON.parse(serializedRecord);\n  if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n    throw Error(\"Unsupported AuthenticationRecord version\");\n  }\n  return parsed;\n}","map":{"version":3,"names":["msalCommon","isNode","AbortError","v4","uuidv4","formatError","formatSuccess","AuthenticationRequiredError","CredentialUnavailableError","DefaultAuthorityHost","DefaultTenantId","LatestAuthenticationRecordVersion","ensureValidMsalToken","scopes","logger","msalToken","getTokenOptions","error","message","getToken","info","Array","isArray","expiresOn","accessToken","getAuthority","tenantId","host","RegExp","test","endsWith","getKnownAuthorities","authorityHost","defaultLoggerCallback","platform","level","containsPii","LogLevel","Error","Info","Verbose","Warning","MsalBaseUtilities","constructor","options","account","authenticationRecord","generateUuid","handleResult","clientId","result","msalToPublic","token","expiresOnTimestamp","getTime","handleError","name","msalError","errorCode","publicToMsal","environment","authority","match","Object","assign","localAccountId","homeAccountId","record","username","version","serializeAuthenticationRecord","JSON","stringify","deserializeAuthenticationRecord","serializedRecord","parsed","parse"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/identity/dist-esm/src/msal/utils.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport * as msalCommon from \"@azure/msal-common\";\nimport { isNode } from \"@azure/core-util\";\nimport { AbortError } from \"@azure/abort-controller\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { formatError, formatSuccess } from \"../util/logging\";\nimport { AuthenticationRequiredError, CredentialUnavailableError } from \"../errors\";\nimport { DefaultAuthorityHost, DefaultTenantId } from \"../constants\";\n/**\n * Latest AuthenticationRecord version\n * @internal\n */\nconst LatestAuthenticationRecordVersion = \"1.0\";\n/**\n * Ensures the validity of the MSAL token\n * @internal\n */\nexport function ensureValidMsalToken(scopes, logger, msalToken, getTokenOptions) {\n    const error = (message) => {\n        logger.getToken.info(message);\n        return new AuthenticationRequiredError({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            getTokenOptions,\n            message,\n        });\n    };\n    if (!msalToken) {\n        throw error(\"No response\");\n    }\n    if (!msalToken.expiresOn) {\n        throw error(`Response had no \"expiresOn\" property.`);\n    }\n    if (!msalToken.accessToken) {\n        throw error(`Response had no \"accessToken\" property.`);\n    }\n}\n/**\n * Generates a valid authority by combining a host with a tenantId.\n * @internal\n */\nexport function getAuthority(tenantId, host) {\n    if (!host) {\n        host = DefaultAuthorityHost;\n    }\n    if (new RegExp(`${tenantId}/?$`).test(host)) {\n        return host;\n    }\n    if (host.endsWith(\"/\")) {\n        return host + tenantId;\n    }\n    else {\n        return `${host}/${tenantId}`;\n    }\n}\n/**\n * Generates the known authorities.\n * If the Tenant Id is `adfs`, the authority can't be validated since the format won't match the expected one.\n * For that reason, we have to force MSAL to disable validating the authority\n * by sending it within the known authorities in the MSAL configuration.\n * @internal\n */\nexport function getKnownAuthorities(tenantId, authorityHost) {\n    if (tenantId === \"adfs\" && authorityHost) {\n        return [authorityHost];\n    }\n    return [];\n}\n/**\n * Generates a logger that can be passed to the MSAL clients.\n * @param logger - The logger of the credential.\n * @internal\n */\nexport const defaultLoggerCallback = (logger, platform = isNode ? \"Node\" : \"Browser\") => (level, message, containsPii) => {\n    if (containsPii) {\n        return;\n    }\n    switch (level) {\n        case msalCommon.LogLevel.Error:\n            logger.info(`MSAL ${platform} V2 error: ${message}`);\n            return;\n        case msalCommon.LogLevel.Info:\n            logger.info(`MSAL ${platform} V2 info message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Verbose:\n            logger.info(`MSAL ${platform} V2 verbose message: ${message}`);\n            return;\n        case msalCommon.LogLevel.Warning:\n            logger.info(`MSAL ${platform} V2 warning: ${message}`);\n            return;\n    }\n};\n/**\n * The common utility functions for the MSAL clients.\n * Defined as a class so that the classes extending this one can have access to its methods and protected properties.\n *\n * It keeps track of a logger and an in-memory copy of the AuthenticationRecord.\n *\n * @internal\n */\nexport class MsalBaseUtilities {\n    constructor(options) {\n        this.logger = options.logger;\n        this.account = options.authenticationRecord;\n    }\n    /**\n     * Generates a UUID\n     */\n    generateUuid() {\n        return uuidv4();\n    }\n    /**\n     * Handles the MSAL authentication result.\n     * If the result has an account, we update the local account reference.\n     * If the token received is invalid, an error will be thrown depending on what's missing.\n     */\n    handleResult(scopes, clientId, result, getTokenOptions) {\n        if (result === null || result === void 0 ? void 0 : result.account) {\n            this.account = msalToPublic(clientId, result.account);\n        }\n        ensureValidMsalToken(scopes, this.logger, result, getTokenOptions);\n        this.logger.getToken.info(formatSuccess(scopes));\n        return {\n            token: result.accessToken,\n            expiresOnTimestamp: result.expiresOn.getTime(),\n        };\n    }\n    /**\n     * Handles MSAL errors.\n     */\n    handleError(scopes, error, getTokenOptions) {\n        if (error.name === \"AuthError\" ||\n            error.name === \"ClientAuthError\" ||\n            error.name === \"BrowserAuthError\") {\n            const msalError = error;\n            switch (msalError.errorCode) {\n                case \"endpoints_resolution_error\":\n                    this.logger.info(formatError(scopes, error.message));\n                    return new CredentialUnavailableError(error.message);\n                case \"device_code_polling_cancelled\":\n                    return new AbortError(\"The authentication has been aborted by the caller.\");\n                case \"consent_required\":\n                case \"interaction_required\":\n                case \"login_required\":\n                    this.logger.info(formatError(scopes, `Authentication returned errorCode ${msalError.errorCode}`));\n                    break;\n                default:\n                    this.logger.info(formatError(scopes, `Failed to acquire token: ${error.message}`));\n                    break;\n            }\n        }\n        if (error.name === \"ClientConfigurationError\" ||\n            error.name === \"BrowserConfigurationAuthError\" ||\n            error.name === \"AbortError\") {\n            return error;\n        }\n        return new AuthenticationRequiredError({ scopes, getTokenOptions, message: error.message });\n    }\n}\n// transformations.ts\nexport function publicToMsal(account) {\n    const [environment] = account.authority.match(/([a-z]*\\.[a-z]*\\.[a-z]*)/) || [];\n    return Object.assign(Object.assign({}, account), { localAccountId: account.homeAccountId, environment });\n}\nexport function msalToPublic(clientId, account) {\n    const record = {\n        authority: getAuthority(account.tenantId, account.environment),\n        homeAccountId: account.homeAccountId,\n        tenantId: account.tenantId || DefaultTenantId,\n        username: account.username,\n        clientId,\n        version: LatestAuthenticationRecordVersion,\n    };\n    return record;\n}\n/**\n * Serializes an `AuthenticationRecord` into a string.\n *\n * The output of a serialized authentication record will contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * To later convert this string to a serialized `AuthenticationRecord`, please use the exported function `deserializeAuthenticationRecord()`.\n */\nexport function serializeAuthenticationRecord(record) {\n    return JSON.stringify(record);\n}\n/**\n * Deserializes a previously serialized authentication record from a string into an object.\n *\n * The input string must contain the following properties:\n *\n * - \"authority\"\n * - \"homeAccountId\"\n * - \"clientId\"\n * - \"tenantId\"\n * - \"username\"\n * - \"version\"\n *\n * If the version we receive is unsupported, an error will be thrown.\n *\n * At the moment, the only available version is: \"1.0\", which is always set when the authentication record is serialized.\n *\n * @param serializedRecord - Authentication record previously serialized into string.\n * @returns AuthenticationRecord.\n */\nexport function deserializeAuthenticationRecord(serializedRecord) {\n    const parsed = JSON.parse(serializedRecord);\n    if (parsed.version && parsed.version !== LatestAuthenticationRecordVersion) {\n        throw Error(\"Unsupported AuthenticationRecord version\");\n    }\n    return parsed;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}