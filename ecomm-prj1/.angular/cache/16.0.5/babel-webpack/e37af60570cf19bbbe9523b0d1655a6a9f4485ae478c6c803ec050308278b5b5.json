{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Class that handles response parsing.\r\n */\nvar ResponseHandler = /** @class */function () {\n  function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {\n    this.clientId = clientId;\n    this.cacheStorage = cacheStorage;\n    this.cryptoObj = cryptoObj;\n    this.logger = logger;\n    this.serializableCache = serializableCache;\n    this.persistencePlugin = persistencePlugin;\n  }\n  /**\r\n   * Function which validates server authorization code response.\r\n   * @param serverResponseHash\r\n   * @param cachedState\r\n   * @param cryptoObj\r\n   */\n  ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\n    if (!serverResponseHash.state || !cachedState) {\n      throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\n    }\n    if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\n      throw ClientAuthError.createStateMismatchError();\n    }\n    // Check for error\n    if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n      }\n      throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\n    }\n    if (serverResponseHash.client_info) {\n      buildClientInfo(serverResponseHash.client_info, cryptoObj);\n    }\n  };\n  /**\r\n   * Function which validates server authorization token response.\r\n   * @param serverResponse\r\n   */\n  ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\n    // Check for error\n    if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\n      if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\n        throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\n      }\n      var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\n      throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\n    }\n  };\n  /**\r\n   * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n   * @param serverTokenResponse\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (serverTokenResponse.id_token) {\n              idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\n              // token nonce check (TODO: Add a warning if no nonce is given?)\n              if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\n                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\n                  throw ClientAuthError.createNonceMismatchError();\n                }\n              }\n              // token max_age check\n              if (request.maxAge || request.maxAge === 0) {\n                authTime = idTokenObj.claims.auth_time;\n                if (!authTime) {\n                  throw ClientAuthError.createAuthTimeNotFoundError();\n                }\n                AuthToken.checkMaxAge(authTime, request.maxAge);\n              }\n            }\n            // generate homeAccountId\n            this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\n            if (!!authCodePayload && !!authCodePayload.state) {\n              requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\n            }\n            // Add keyId from request to serverTokenResponse if defined\n            serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\n            cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1,, 5, 8]);\n            if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\n            this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\n            cacheContext = new TokenCacheContext(this.serializableCache, true);\n            return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\n          case 2:\n            _a.sent();\n            _a.label = 3;\n          case 3:\n            /*\r\n             * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n             * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n             * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n             * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n             */\n            if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\n              key = cacheRecord.account.generateAccountKey();\n              account = this.cacheStorage.getAccount(key);\n              if (!account) {\n                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\n                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\n              }\n            }\n            return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\n          case 4:\n            _a.sent();\n            return [3 /*break*/, 8];\n          case 5:\n            if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\n            this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\n            return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\n          case 6:\n            _a.sent();\n            _a.label = 7;\n          case 7:\n            return [7 /*endfinally*/];\n          case 8:\n            return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code, serverRequestId)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Generates CacheRecord\r\n   * @param serverTokenResponse\r\n   * @param idTokenObj\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\n    var env = authority.getPreferredCache();\n    if (StringUtils.isEmpty(env)) {\n      throw ClientAuthError.createInvalidCacheEnvironmentError();\n    }\n    // IdToken: non AAD scenarios can have empty realm\n    var cachedIdToken;\n    var cachedAccount;\n    if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\n      cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\n      cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\n    }\n    // AccessToken\n    var cachedAccessToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\n      // If scopes not returned in server response, use request scopes\n      var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\n      /*\r\n       * Use timestamp calculated before request\r\n       * Server may return timestamps as strings, parse to numbers if so.\r\n       */\n      var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\n      var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\n      var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\n      var tokenExpirationSeconds = reqTimestamp + expiresIn;\n      var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\n      var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\n      // non AAD scenarios can have empty realm\n      cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\n    }\n    // refreshToken\n    var cachedRefreshToken = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\n      cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\n    }\n    // appMetadata\n    var cachedAppMetadata = null;\n    if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\n      cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\n    }\n    return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\n  };\n  /**\r\n   * Generate Account\r\n   * @param serverTokenResponse\r\n   * @param idToken\r\n   * @param authority\r\n   */\n  ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\n    var authorityType = authority.authorityType;\n    var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\n    var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\n    // ADFS does not require client_info in the response\n    if (authorityType === AuthorityType.Adfs) {\n      this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\n      return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n    }\n    // This fallback applies to B2C as well as they fall under an AAD account type.\n    if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\n      throw ClientAuthError.createClientInfoEmptyError();\n    }\n    return serverTokenResponse.client_info ? AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) : AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\n  };\n  /**\r\n   * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n   *\r\n   * Optionally takes a state string that is set as-is in the response.\r\n   *\r\n   * @param cacheRecord\r\n   * @param idTokenObj\r\n   * @param fromTokenCache\r\n   * @param stateString\r\n   */\n  ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code, requestId) {\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function () {\n      var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\n      return __generator(this, function (_e) {\n        switch (_e.label) {\n          case 0:\n            accessToken = Constants.EMPTY_STRING;\n            responseScopes = [];\n            expiresOn = null;\n            familyId = Constants.EMPTY_STRING;\n            if (!cacheRecord.accessToken) return [3 /*break*/, 4];\n            if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\n            popTokenGenerator = new PopTokenGenerator(cryptoObj);\n            _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\n            if (!keyId) {\n              throw ClientAuthError.createKeyIdMissingError();\n            }\n            return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\n          case 1:\n            accessToken = _e.sent();\n            return [3 /*break*/, 3];\n          case 2:\n            accessToken = cacheRecord.accessToken.secret;\n            _e.label = 3;\n          case 3:\n            responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\n            expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\n            extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\n            _e.label = 4;\n          case 4:\n            if (cacheRecord.appMetadata) {\n              familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\n            }\n            uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\n            tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\n            return [2 /*return*/, {\n              authority: authority.canonicalAuthority,\n              uniqueId: uid,\n              tenantId: tid,\n              scopes: responseScopes,\n              account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\n              idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\n              idTokenClaims: idTokenObj ? idTokenObj.claims : {},\n              accessToken: accessToken,\n              fromCache: fromTokenCache,\n              expiresOn: expiresOn,\n              correlationId: request.correlationId,\n              requestId: requestId || Constants.EMPTY_STRING,\n              extExpiresOn: extExpiresOn,\n              familyId: familyId,\n              tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\n              state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\n              cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\n              msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\n              code: code,\n              fromNativeBroker: false\n            }];\n        }\n      });\n    });\n  };\n  return ResponseHandler;\n}();\nexport { ResponseHandler };","map":{"version":3,"names":["__awaiter","__generator","buildClientInfo","ClientAuthError","StringUtils","ServerError","AuthToken","ScopeSet","AccountEntity","AuthorityType","IdTokenEntity","AccessTokenEntity","RefreshTokenEntity","InteractionRequiredAuthError","CacheRecord","ProtocolUtils","Constants","AuthenticationScheme","THE_FAMILY_ID","PopTokenGenerator","AppMetadataEntity","TokenCacheContext","ResponseHandler","clientId","cacheStorage","cryptoObj","logger","serializableCache","persistencePlugin","prototype","validateServerAuthorizationCodeResponse","serverResponseHash","cachedState","state","createStateNotFoundError","decodeURIComponent","createStateMismatchError","error","error_description","suberror","isInteractionRequiredError","EMPTY_STRING","client_info","validateTokenResponse","serverResponse","errString","error_codes","timestamp","correlation_id","trace_id","handleServerTokenResponse","serverTokenResponse","authority","reqTimestamp","request","authCodePayload","userAssertionHash","handlingRefreshTokenResponse","forceCacheRefreshTokenResponse","serverRequestId","idTokenObj","authTime","requestStateObj","cacheRecord","cacheContext","key","account","_a","label","id_token","isEmpty","nonce","claims","createNonceMismatchError","maxAge","auth_time","createAuthTimeNotFoundError","checkMaxAge","homeAccountIdentifier","generateHomeAccountId","authorityType","parseRequestState","key_id","sshKid","undefined","generateCacheRecord","trys","push","verbose","beforeCacheAccess","sent","generateAccountKey","getAccount","warning","generateAuthenticationResult","saveCacheRecord","afterCacheAccess","spa_code","env","getPreferredCache","createInvalidCacheEnvironmentError","cachedIdToken","cachedAccount","createIdTokenEntity","tid","generateAccountEntity","cachedAccessToken","access_token","responseScopes","scope","fromString","scopes","expiresIn","expires_in","parseInt","extExpiresIn","ext_expires_in","refreshIn","refresh_in","tokenExpirationSeconds","extendedTokenExpirationSeconds","refreshOnSeconds","createAccessTokenEntity","tenant","printScopes","token_type","requestedClaimsHash","cachedRefreshToken","refresh_token","createRefreshTokenEntity","foci","cachedAppMetadata","createAppMetadataEntity","idToken","cloudGraphHostName","cloud_graph_host_name","msGraphhost","msgraph_host","Adfs","createGenericAccount","protocolMode","createClientInfoEmptyError","createAccount","fromTokenCache","requestState","code","requestId","_b","_c","accessToken","expiresOn","extExpiresOn","familyId","popTokenGenerator","_d","secret","keyId","uid","_e","tokenType","POP","createKeyIdMissingError","signPopToken","target","asArray","Date","Number","extendedExpiresOn","appMetadata","oid","sub","canonicalAuthority","uniqueId","tenantId","getAccountInfo","rawToken","idTokenClaims","fromCache","correlationId","userRequestState","msGraphHost","fromNativeBroker"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-common/dist/response/ResponseHandler.js"],"sourcesContent":["/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { buildClientInfo } from '../account/ClientInfo.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { StringUtils } from '../utils/StringUtils.js';\nimport { ServerError } from '../error/ServerError.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from '../cache/entities/AccountEntity.js';\nimport { AuthorityType } from '../authority/AuthorityType.js';\nimport { IdTokenEntity } from '../cache/entities/IdTokenEntity.js';\nimport { AccessTokenEntity } from '../cache/entities/AccessTokenEntity.js';\nimport { RefreshTokenEntity } from '../cache/entities/RefreshTokenEntity.js';\nimport { InteractionRequiredAuthError } from '../error/InteractionRequiredAuthError.js';\nimport { CacheRecord } from '../cache/entities/CacheRecord.js';\nimport { ProtocolUtils } from '../utils/ProtocolUtils.js';\nimport { Constants, AuthenticationScheme, THE_FAMILY_ID } from '../utils/Constants.js';\nimport { PopTokenGenerator } from '../crypto/PopTokenGenerator.js';\nimport { AppMetadataEntity } from '../cache/entities/AppMetadataEntity.js';\nimport { TokenCacheContext } from '../cache/persistence/TokenCacheContext.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Class that handles response parsing.\r\n */\r\nvar ResponseHandler = /** @class */ (function () {\r\n    function ResponseHandler(clientId, cacheStorage, cryptoObj, logger, serializableCache, persistencePlugin) {\r\n        this.clientId = clientId;\r\n        this.cacheStorage = cacheStorage;\r\n        this.cryptoObj = cryptoObj;\r\n        this.logger = logger;\r\n        this.serializableCache = serializableCache;\r\n        this.persistencePlugin = persistencePlugin;\r\n    }\r\n    /**\r\n     * Function which validates server authorization code response.\r\n     * @param serverResponseHash\r\n     * @param cachedState\r\n     * @param cryptoObj\r\n     */\r\n    ResponseHandler.prototype.validateServerAuthorizationCodeResponse = function (serverResponseHash, cachedState, cryptoObj) {\r\n        if (!serverResponseHash.state || !cachedState) {\r\n            throw !serverResponseHash.state ? ClientAuthError.createStateNotFoundError(\"Server State\") : ClientAuthError.createStateNotFoundError(\"Cached State\");\r\n        }\r\n        if (decodeURIComponent(serverResponseHash.state) !== decodeURIComponent(cachedState)) {\r\n            throw ClientAuthError.createStateMismatchError();\r\n        }\r\n        // Check for error\r\n        if (serverResponseHash.error || serverResponseHash.error_description || serverResponseHash.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponseHash.error, serverResponseHash.error_description, serverResponseHash.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n            }\r\n            throw new ServerError(serverResponseHash.error || Constants.EMPTY_STRING, serverResponseHash.error_description, serverResponseHash.suberror);\r\n        }\r\n        if (serverResponseHash.client_info) {\r\n            buildClientInfo(serverResponseHash.client_info, cryptoObj);\r\n        }\r\n    };\r\n    /**\r\n     * Function which validates server authorization token response.\r\n     * @param serverResponse\r\n     */\r\n    ResponseHandler.prototype.validateTokenResponse = function (serverResponse) {\r\n        // Check for error\r\n        if (serverResponse.error || serverResponse.error_description || serverResponse.suberror) {\r\n            if (InteractionRequiredAuthError.isInteractionRequiredError(serverResponse.error, serverResponse.error_description, serverResponse.suberror)) {\r\n                throw new InteractionRequiredAuthError(serverResponse.error, serverResponse.error_description, serverResponse.suberror);\r\n            }\r\n            var errString = serverResponse.error_codes + \" - [\" + serverResponse.timestamp + \"]: \" + serverResponse.error_description + \" - Correlation ID: \" + serverResponse.correlation_id + \" - Trace ID: \" + serverResponse.trace_id;\r\n            throw new ServerError(serverResponse.error, errString, serverResponse.suberror);\r\n        }\r\n    };\r\n    /**\r\n     * Returns a constructed token response based on given string. Also manages the cache updates and cleanups.\r\n     * @param serverTokenResponse\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.handleServerTokenResponse = function (serverTokenResponse, authority, reqTimestamp, request, authCodePayload, userAssertionHash, handlingRefreshTokenResponse, forceCacheRefreshTokenResponse, serverRequestId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var idTokenObj, authTime, requestStateObj, cacheRecord, cacheContext, key, account;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (serverTokenResponse.id_token) {\r\n                            idTokenObj = new AuthToken(serverTokenResponse.id_token || Constants.EMPTY_STRING, this.cryptoObj);\r\n                            // token nonce check (TODO: Add a warning if no nonce is given?)\r\n                            if (authCodePayload && !StringUtils.isEmpty(authCodePayload.nonce)) {\r\n                                if (idTokenObj.claims.nonce !== authCodePayload.nonce) {\r\n                                    throw ClientAuthError.createNonceMismatchError();\r\n                                }\r\n                            }\r\n                            // token max_age check\r\n                            if (request.maxAge || (request.maxAge === 0)) {\r\n                                authTime = idTokenObj.claims.auth_time;\r\n                                if (!authTime) {\r\n                                    throw ClientAuthError.createAuthTimeNotFoundError();\r\n                                }\r\n                                AuthToken.checkMaxAge(authTime, request.maxAge);\r\n                            }\r\n                        }\r\n                        // generate homeAccountId\r\n                        this.homeAccountIdentifier = AccountEntity.generateHomeAccountId(serverTokenResponse.client_info || Constants.EMPTY_STRING, authority.authorityType, this.logger, this.cryptoObj, idTokenObj);\r\n                        if (!!authCodePayload && !!authCodePayload.state) {\r\n                            requestStateObj = ProtocolUtils.parseRequestState(this.cryptoObj, authCodePayload.state);\r\n                        }\r\n                        // Add keyId from request to serverTokenResponse if defined\r\n                        serverTokenResponse.key_id = serverTokenResponse.key_id || request.sshKid || undefined;\r\n                        cacheRecord = this.generateCacheRecord(serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload);\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, , 5, 8]);\r\n                        if (!(this.persistencePlugin && this.serializableCache)) return [3 /*break*/, 3];\r\n                        this.logger.verbose(\"Persistence enabled, calling beforeCacheAccess\");\r\n                        cacheContext = new TokenCacheContext(this.serializableCache, true);\r\n                        return [4 /*yield*/, this.persistencePlugin.beforeCacheAccess(cacheContext)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        _a.label = 3;\r\n                    case 3:\r\n                        /*\r\n                         * When saving a refreshed tokens to the cache, it is expected that the account that was used is present in the cache.\r\n                         * If not present, we should return null, as it's the case that another application called removeAccount in between\r\n                         * the calls to getAllAccounts and acquireTokenSilent. We should not overwrite that removal, unless explicitly flagged by\r\n                         * the developer, as in the case of refresh token flow used in ADAL Node to MSAL Node migration.\r\n                         */\r\n                        if (handlingRefreshTokenResponse && !forceCacheRefreshTokenResponse && cacheRecord.account) {\r\n                            key = cacheRecord.account.generateAccountKey();\r\n                            account = this.cacheStorage.getAccount(key);\r\n                            if (!account) {\r\n                                this.logger.warning(\"Account used to refresh tokens not in persistence, refreshed tokens will not be stored in the cache\");\r\n                                return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, undefined, serverRequestId)];\r\n                            }\r\n                        }\r\n                        return [4 /*yield*/, this.cacheStorage.saveCacheRecord(cacheRecord)];\r\n                    case 4:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 8];\r\n                    case 5:\r\n                        if (!(this.persistencePlugin && this.serializableCache && cacheContext)) return [3 /*break*/, 7];\r\n                        this.logger.verbose(\"Persistence enabled, calling afterCacheAccess\");\r\n                        return [4 /*yield*/, this.persistencePlugin.afterCacheAccess(cacheContext)];\r\n                    case 6:\r\n                        _a.sent();\r\n                        _a.label = 7;\r\n                    case 7: return [7 /*endfinally*/];\r\n                    case 8: return [2 /*return*/, ResponseHandler.generateAuthenticationResult(this.cryptoObj, authority, cacheRecord, false, request, idTokenObj, requestStateObj, serverTokenResponse.spa_code, serverRequestId)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Generates CacheRecord\r\n     * @param serverTokenResponse\r\n     * @param idTokenObj\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateCacheRecord = function (serverTokenResponse, authority, reqTimestamp, request, idTokenObj, userAssertionHash, authCodePayload) {\r\n        var env = authority.getPreferredCache();\r\n        if (StringUtils.isEmpty(env)) {\r\n            throw ClientAuthError.createInvalidCacheEnvironmentError();\r\n        }\r\n        // IdToken: non AAD scenarios can have empty realm\r\n        var cachedIdToken;\r\n        var cachedAccount;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.id_token) && !!idTokenObj) {\r\n            cachedIdToken = IdTokenEntity.createIdTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.id_token || Constants.EMPTY_STRING, this.clientId, idTokenObj.claims.tid || Constants.EMPTY_STRING);\r\n            cachedAccount = this.generateAccountEntity(serverTokenResponse, idTokenObj, authority, authCodePayload);\r\n        }\r\n        // AccessToken\r\n        var cachedAccessToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.access_token)) {\r\n            // If scopes not returned in server response, use request scopes\r\n            var responseScopes = serverTokenResponse.scope ? ScopeSet.fromString(serverTokenResponse.scope) : new ScopeSet(request.scopes || []);\r\n            /*\r\n             * Use timestamp calculated before request\r\n             * Server may return timestamps as strings, parse to numbers if so.\r\n             */\r\n            var expiresIn = (typeof serverTokenResponse.expires_in === \"string\" ? parseInt(serverTokenResponse.expires_in, 10) : serverTokenResponse.expires_in) || 0;\r\n            var extExpiresIn = (typeof serverTokenResponse.ext_expires_in === \"string\" ? parseInt(serverTokenResponse.ext_expires_in, 10) : serverTokenResponse.ext_expires_in) || 0;\r\n            var refreshIn = (typeof serverTokenResponse.refresh_in === \"string\" ? parseInt(serverTokenResponse.refresh_in, 10) : serverTokenResponse.refresh_in) || undefined;\r\n            var tokenExpirationSeconds = reqTimestamp + expiresIn;\r\n            var extendedTokenExpirationSeconds = tokenExpirationSeconds + extExpiresIn;\r\n            var refreshOnSeconds = refreshIn && refreshIn > 0 ? reqTimestamp + refreshIn : undefined;\r\n            // non AAD scenarios can have empty realm\r\n            cachedAccessToken = AccessTokenEntity.createAccessTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.access_token || Constants.EMPTY_STRING, this.clientId, idTokenObj ? idTokenObj.claims.tid || Constants.EMPTY_STRING : authority.tenant, responseScopes.printScopes(), tokenExpirationSeconds, extendedTokenExpirationSeconds, this.cryptoObj, refreshOnSeconds, serverTokenResponse.token_type, userAssertionHash, serverTokenResponse.key_id, request.claims, request.requestedClaimsHash);\r\n        }\r\n        // refreshToken\r\n        var cachedRefreshToken = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.refresh_token)) {\r\n            cachedRefreshToken = RefreshTokenEntity.createRefreshTokenEntity(this.homeAccountIdentifier, env, serverTokenResponse.refresh_token || Constants.EMPTY_STRING, this.clientId, serverTokenResponse.foci, userAssertionHash);\r\n        }\r\n        // appMetadata\r\n        var cachedAppMetadata = null;\r\n        if (!StringUtils.isEmpty(serverTokenResponse.foci)) {\r\n            cachedAppMetadata = AppMetadataEntity.createAppMetadataEntity(this.clientId, env, serverTokenResponse.foci);\r\n        }\r\n        return new CacheRecord(cachedAccount, cachedIdToken, cachedAccessToken, cachedRefreshToken, cachedAppMetadata);\r\n    };\r\n    /**\r\n     * Generate Account\r\n     * @param serverTokenResponse\r\n     * @param idToken\r\n     * @param authority\r\n     */\r\n    ResponseHandler.prototype.generateAccountEntity = function (serverTokenResponse, idToken, authority, authCodePayload) {\r\n        var authorityType = authority.authorityType;\r\n        var cloudGraphHostName = authCodePayload ? authCodePayload.cloud_graph_host_name : Constants.EMPTY_STRING;\r\n        var msGraphhost = authCodePayload ? authCodePayload.msgraph_host : Constants.EMPTY_STRING;\r\n        // ADFS does not require client_info in the response\r\n        if (authorityType === AuthorityType.Adfs) {\r\n            this.logger.verbose(\"Authority type is ADFS, creating ADFS account\");\r\n            return AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n        }\r\n        // This fallback applies to B2C as well as they fall under an AAD account type.\r\n        if (StringUtils.isEmpty(serverTokenResponse.client_info) && authority.protocolMode === \"AAD\") {\r\n            throw ClientAuthError.createClientInfoEmptyError();\r\n        }\r\n        return serverTokenResponse.client_info ?\r\n            AccountEntity.createAccount(serverTokenResponse.client_info, this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost) :\r\n            AccountEntity.createGenericAccount(this.homeAccountIdentifier, idToken, authority, cloudGraphHostName, msGraphhost);\r\n    };\r\n    /**\r\n     * Creates an @AuthenticationResult from @CacheRecord , @IdToken , and a boolean that states whether or not the result is from cache.\r\n     *\r\n     * Optionally takes a state string that is set as-is in the response.\r\n     *\r\n     * @param cacheRecord\r\n     * @param idTokenObj\r\n     * @param fromTokenCache\r\n     * @param stateString\r\n     */\r\n    ResponseHandler.generateAuthenticationResult = function (cryptoObj, authority, cacheRecord, fromTokenCache, request, idTokenObj, requestState, code, requestId) {\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var accessToken, responseScopes, expiresOn, extExpiresOn, familyId, popTokenGenerator, _d, secret, keyId, uid, tid;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        accessToken = Constants.EMPTY_STRING;\r\n                        responseScopes = [];\r\n                        expiresOn = null;\r\n                        familyId = Constants.EMPTY_STRING;\r\n                        if (!cacheRecord.accessToken) return [3 /*break*/, 4];\r\n                        if (!(cacheRecord.accessToken.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 2];\r\n                        popTokenGenerator = new PopTokenGenerator(cryptoObj);\r\n                        _d = cacheRecord.accessToken, secret = _d.secret, keyId = _d.keyId;\r\n                        if (!keyId) {\r\n                            throw ClientAuthError.createKeyIdMissingError();\r\n                        }\r\n                        return [4 /*yield*/, popTokenGenerator.signPopToken(secret, keyId, request)];\r\n                    case 1:\r\n                        accessToken = _e.sent();\r\n                        return [3 /*break*/, 3];\r\n                    case 2:\r\n                        accessToken = cacheRecord.accessToken.secret;\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        responseScopes = ScopeSet.fromString(cacheRecord.accessToken.target).asArray();\r\n                        expiresOn = new Date(Number(cacheRecord.accessToken.expiresOn) * 1000);\r\n                        extExpiresOn = new Date(Number(cacheRecord.accessToken.extendedExpiresOn) * 1000);\r\n                        _e.label = 4;\r\n                    case 4:\r\n                        if (cacheRecord.appMetadata) {\r\n                            familyId = cacheRecord.appMetadata.familyId === THE_FAMILY_ID ? THE_FAMILY_ID : Constants.EMPTY_STRING;\r\n                        }\r\n                        uid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.oid) || (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.sub) || Constants.EMPTY_STRING;\r\n                        tid = (idTokenObj === null || idTokenObj === void 0 ? void 0 : idTokenObj.claims.tid) || Constants.EMPTY_STRING;\r\n                        return [2 /*return*/, {\r\n                                authority: authority.canonicalAuthority,\r\n                                uniqueId: uid,\r\n                                tenantId: tid,\r\n                                scopes: responseScopes,\r\n                                account: cacheRecord.account ? cacheRecord.account.getAccountInfo() : null,\r\n                                idToken: idTokenObj ? idTokenObj.rawToken : Constants.EMPTY_STRING,\r\n                                idTokenClaims: idTokenObj ? idTokenObj.claims : {},\r\n                                accessToken: accessToken,\r\n                                fromCache: fromTokenCache,\r\n                                expiresOn: expiresOn,\r\n                                correlationId: request.correlationId,\r\n                                requestId: requestId || Constants.EMPTY_STRING,\r\n                                extExpiresOn: extExpiresOn,\r\n                                familyId: familyId,\r\n                                tokenType: ((_a = cacheRecord.accessToken) === null || _a === void 0 ? void 0 : _a.tokenType) || Constants.EMPTY_STRING,\r\n                                state: requestState ? requestState.userRequestState : Constants.EMPTY_STRING,\r\n                                cloudGraphHostName: ((_b = cacheRecord.account) === null || _b === void 0 ? void 0 : _b.cloudGraphHostName) || Constants.EMPTY_STRING,\r\n                                msGraphHost: ((_c = cacheRecord.account) === null || _c === void 0 ? void 0 : _c.msGraphHost) || Constants.EMPTY_STRING,\r\n                                code: code,\r\n                                fromNativeBroker: false\r\n                            }];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return ResponseHandler;\r\n}());\n\nexport { ResponseHandler };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}