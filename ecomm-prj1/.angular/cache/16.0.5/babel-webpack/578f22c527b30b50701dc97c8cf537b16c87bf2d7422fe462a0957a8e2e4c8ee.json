{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nfunction defaultAuthorizeRequest(_x) {\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction _defaultAuthorizeRequest() {\n  _defaultAuthorizeRequest = _asyncToGenerator(function* (options) {\n    const {\n      scopes,\n      getAccessToken,\n      request\n    } = options;\n    const getTokenOptions = {\n      abortSignal: request.abortSignal,\n      tracingOptions: request.tracingOptions\n    };\n    const accessToken = yield getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n      options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n  });\n  return _defaultAuthorizeRequest.apply(this, arguments);\n}\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n  var _a;\n  const {\n    credential,\n    scopes,\n    challengeCallbacks\n  } = options;\n  const logger = options.logger || coreLogger;\n  const callbacks = Object.assign({\n    authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest,\n    authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge\n  }, challengeCallbacks);\n  // This function encapsulates the entire process of reliably retrieving the token\n  // The options are left out of the public API until there's demand to configure this.\n  // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n  // in order to pass through the `options` object.\n  const getAccessToken = credential ? createTokenCycler(credential /* , options */) : () => Promise.resolve(null);\n  return {\n    name: bearerTokenAuthenticationPolicyName,\n    /**\n     * If there's no challenge parameter:\n     * - It will try to retrieve the token using the cache, or the credential's getToken.\n     * - Then it will try the next policy with or without the retrieved token.\n     *\n     * It uses the challenge parameters to:\n     * - Skip a first attempt to get the token from the credential if there's no cached token,\n     *   since it expects the token to be retrievable only after the challenge.\n     * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n     * - Send an initial request to receive the challenge if it fails.\n     * - Process a challenge if the response contains it.\n     * - Retrieve a token with the challenge information, then re-send the request.\n     */\n    sendRequest(request, next) {\n      return _asyncToGenerator(function* () {\n        if (!request.url.toLowerCase().startsWith(\"https://\")) {\n          throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n        }\n        yield callbacks.authorizeRequest({\n          scopes: Array.isArray(scopes) ? scopes : [scopes],\n          request,\n          getAccessToken,\n          logger\n        });\n        let response;\n        let error;\n        try {\n          response = yield next(request);\n        } catch (err) {\n          error = err;\n          response = err.response;\n        }\n        if (callbacks.authorizeRequestOnChallenge && (response === null || response === void 0 ? void 0 : response.status) === 401 && getChallenge(response)) {\n          // processes challenge\n          const shouldSendRequest = yield callbacks.authorizeRequestOnChallenge({\n            scopes: Array.isArray(scopes) ? scopes : [scopes],\n            request,\n            response,\n            getAccessToken,\n            logger\n          });\n          if (shouldSendRequest) {\n            return next(request);\n          }\n        }\n        if (error) {\n          throw error;\n        } else {\n          return response;\n        }\n      })();\n    }\n  };\n}","map":{"version":3,"names":["createTokenCycler","logger","coreLogger","bearerTokenAuthenticationPolicyName","defaultAuthorizeRequest","_x","_defaultAuthorizeRequest","apply","arguments","_asyncToGenerator","options","scopes","getAccessToken","request","getTokenOptions","abortSignal","tracingOptions","accessToken","headers","set","token","getChallenge","response","challenge","get","status","bearerTokenAuthenticationPolicy","_a","credential","challengeCallbacks","callbacks","Object","assign","authorizeRequest","authorizeRequestOnChallenge","Promise","resolve","name","sendRequest","next","url","toLowerCase","startsWith","Error","Array","isArray","error","err","shouldSendRequest"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/core-rest-pipeline/dist-esm/src/policies/bearerTokenAuthenticationPolicy.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { createTokenCycler } from \"../util/tokenCycler\";\nimport { logger as coreLogger } from \"../log\";\n/**\n * The programmatic identifier of the bearerTokenAuthenticationPolicy.\n */\nexport const bearerTokenAuthenticationPolicyName = \"bearerTokenAuthenticationPolicy\";\n/**\n * Default authorize request handler\n */\nasync function defaultAuthorizeRequest(options) {\n    const { scopes, getAccessToken, request } = options;\n    const getTokenOptions = {\n        abortSignal: request.abortSignal,\n        tracingOptions: request.tracingOptions,\n    };\n    const accessToken = await getAccessToken(scopes, getTokenOptions);\n    if (accessToken) {\n        options.request.headers.set(\"Authorization\", `Bearer ${accessToken.token}`);\n    }\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * A policy that can request a token from a TokenCredential implementation and\n * then apply it to the Authorization header of a request as a Bearer token.\n */\nexport function bearerTokenAuthenticationPolicy(options) {\n    var _a;\n    const { credential, scopes, challengeCallbacks } = options;\n    const logger = options.logger || coreLogger;\n    const callbacks = Object.assign({ authorizeRequest: (_a = challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequest) !== null && _a !== void 0 ? _a : defaultAuthorizeRequest, authorizeRequestOnChallenge: challengeCallbacks === null || challengeCallbacks === void 0 ? void 0 : challengeCallbacks.authorizeRequestOnChallenge }, challengeCallbacks);\n    // This function encapsulates the entire process of reliably retrieving the token\n    // The options are left out of the public API until there's demand to configure this.\n    // Remember to extend `BearerTokenAuthenticationPolicyOptions` with `TokenCyclerOptions`\n    // in order to pass through the `options` object.\n    const getAccessToken = credential\n        ? createTokenCycler(credential /* , options */)\n        : () => Promise.resolve(null);\n    return {\n        name: bearerTokenAuthenticationPolicyName,\n        /**\n         * If there's no challenge parameter:\n         * - It will try to retrieve the token using the cache, or the credential's getToken.\n         * - Then it will try the next policy with or without the retrieved token.\n         *\n         * It uses the challenge parameters to:\n         * - Skip a first attempt to get the token from the credential if there's no cached token,\n         *   since it expects the token to be retrievable only after the challenge.\n         * - Prepare the outgoing request if the `prepareRequest` method has been provided.\n         * - Send an initial request to receive the challenge if it fails.\n         * - Process a challenge if the response contains it.\n         * - Retrieve a token with the challenge information, then re-send the request.\n         */\n        async sendRequest(request, next) {\n            if (!request.url.toLowerCase().startsWith(\"https://\")) {\n                throw new Error(\"Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.\");\n            }\n            await callbacks.authorizeRequest({\n                scopes: Array.isArray(scopes) ? scopes : [scopes],\n                request,\n                getAccessToken,\n                logger,\n            });\n            let response;\n            let error;\n            try {\n                response = await next(request);\n            }\n            catch (err) {\n                error = err;\n                response = err.response;\n            }\n            if (callbacks.authorizeRequestOnChallenge &&\n                (response === null || response === void 0 ? void 0 : response.status) === 401 &&\n                getChallenge(response)) {\n                // processes challenge\n                const shouldSendRequest = await callbacks.authorizeRequestOnChallenge({\n                    scopes: Array.isArray(scopes) ? scopes : [scopes],\n                    request,\n                    response,\n                    getAccessToken,\n                    logger,\n                });\n                if (shouldSendRequest) {\n                    return next(request);\n                }\n            }\n            if (error) {\n                throw error;\n            }\n            else {\n                return response;\n            }\n        },\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}