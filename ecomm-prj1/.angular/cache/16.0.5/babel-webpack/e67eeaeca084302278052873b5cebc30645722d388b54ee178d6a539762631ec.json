{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _bl = _interopRequireDefault(require(\"bl\"));\nvar _stream = require(\"stream\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _errors = require(\"./errors\");\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends _stream.Transform {\n  constructor(debug) {\n    super({\n      readableObjectMode: true\n    });\n    this.debug = void 0;\n    this.bl = void 0;\n    this.currentMessage = void 0;\n    this.debug = debug;\n    this.currentMessage = undefined;\n    this.bl = new _bl.default();\n  }\n  pause() {\n    super.pause();\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n    return this;\n  }\n  resume() {\n    super.resume();\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n    return this;\n  }\n  processBufferedData(callback) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= _packet.HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n      if (length < _packet.HEADER_LENGTH) {\n        return callback(new _errors.ConnectionError('Unable to process incoming packet'));\n      }\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length); // TODO: Get rid of creating `Packet` instances here.\n\n        const packet = new _packet.Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n        let message = this.currentMessage;\n        if (message === undefined) {\n          this.currentMessage = message = new _message.default({\n            type: packet.type(),\n            resetConnection: false\n          });\n          this.push(message);\n        }\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    } // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n\n    callback();\n  }\n  _transform(chunk, _encoding, callback) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n}\nvar _default = IncomingMessageStream;\nexports.default = _default;\nmodule.exports = IncomingMessageStream;","map":{"version":3,"names":["Object","defineProperty","exports","value","default","_bl","_interopRequireDefault","require","_stream","_message","_packet","_errors","obj","__esModule","IncomingMessageStream","Transform","constructor","debug","readableObjectMode","bl","currentMessage","undefined","pause","resume","processBufferedData","callback","length","HEADER_LENGTH","readUInt16BE","ConnectionError","data","slice","consume","packet","Packet","message","type","resetConnection","push","isLast","once","end","write","_transform","chunk","_encoding","append","_default","module"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/tedious/lib/incoming-message-stream.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _bl = _interopRequireDefault(require(\"bl\"));\n\nvar _stream = require(\"stream\");\n\nvar _message = _interopRequireDefault(require(\"./message\"));\n\nvar _packet = require(\"./packet\");\n\nvar _errors = require(\"./errors\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n  IncomingMessageStream\n  Transform received TDS data into individual IncomingMessage streams.\n*/\nclass IncomingMessageStream extends _stream.Transform {\n  constructor(debug) {\n    super({\n      readableObjectMode: true\n    });\n    this.debug = void 0;\n    this.bl = void 0;\n    this.currentMessage = void 0;\n    this.debug = debug;\n    this.currentMessage = undefined;\n    this.bl = new _bl.default();\n  }\n\n  pause() {\n    super.pause();\n\n    if (this.currentMessage) {\n      this.currentMessage.pause();\n    }\n\n    return this;\n  }\n\n  resume() {\n    super.resume();\n\n    if (this.currentMessage) {\n      this.currentMessage.resume();\n    }\n\n    return this;\n  }\n\n  processBufferedData(callback) {\n    // The packet header is always 8 bytes of length.\n    while (this.bl.length >= _packet.HEADER_LENGTH) {\n      // Get the full packet length\n      const length = this.bl.readUInt16BE(2);\n\n      if (length < _packet.HEADER_LENGTH) {\n        return callback(new _errors.ConnectionError('Unable to process incoming packet'));\n      }\n\n      if (this.bl.length >= length) {\n        const data = this.bl.slice(0, length);\n        this.bl.consume(length); // TODO: Get rid of creating `Packet` instances here.\n\n        const packet = new _packet.Packet(data);\n        this.debug.packet('Received', packet);\n        this.debug.data(packet);\n        let message = this.currentMessage;\n\n        if (message === undefined) {\n          this.currentMessage = message = new _message.default({\n            type: packet.type(),\n            resetConnection: false\n          });\n          this.push(message);\n        }\n\n        if (packet.isLast()) {\n          // Wait until the current message was fully processed before we\n          // continue processing any remaining messages.\n          message.once('end', () => {\n            this.currentMessage = undefined;\n            this.processBufferedData(callback);\n          });\n          message.end(packet.data());\n          return;\n        } else if (!message.write(packet.data())) {\n          // If too much data is buffering up in the\n          // current message, wait for it to drain.\n          message.once('drain', () => {\n            this.processBufferedData(callback);\n          });\n          return;\n        }\n      } else {\n        break;\n      }\n    } // Not enough data to read the next packet. Stop here and wait for\n    // the next call to `_transform`.\n\n\n    callback();\n  }\n\n  _transform(chunk, _encoding, callback) {\n    this.bl.append(chunk);\n    this.processBufferedData(callback);\n  }\n\n}\n\nvar _default = IncomingMessageStream;\nexports.default = _default;\nmodule.exports = IncomingMessageStream;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}