{"ast":null,"code":"/*! @azure/msal-common v13.1.0 2023-06-07 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AuthenticationScheme, CredentialType, GrantType, AADServerParamKeys, CacheOutcome, Constants } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * On-Behalf-Of client\r\n */\nvar OnBehalfOfClient = /** @class */function (_super) {\n  __extends(OnBehalfOfClient, _super);\n  function OnBehalfOfClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Public API to acquire tokens with on behalf of flow\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.scopeSet = new ScopeSet(request.scopes || []);\n            // generate the user_assertion_hash for OBOAssertion\n            _a = this;\n            return [4 /*yield*/, this.cryptoUtils.hashString(request.oboAssertion)];\n          case 1:\n            // generate the user_assertion_hash for OBOAssertion\n            _a.userAssertionHash = _b.sent();\n            if (!request.skipCache) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n          case 3:\n            _b.trys.push([3, 5,, 7]);\n            return [4 /*yield*/, this.getCachedAuthenticationResult(request)];\n          case 4:\n            return [2 /*return*/, _b.sent()];\n          case 5:\n            _b.sent();\n            return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\n          case 6:\n            // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\n            return [2 /*return*/, _b.sent()];\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * look up cache for tokens\r\n   * Find idtoken in the cache\r\n   * Find accessToken based on user assertion and account info in the cache\r\n   * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\r\n   * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.getCachedAuthenticationResult = function (request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);\n            if (!cachedAccessToken) {\n              // Must refresh due to non-existent access_token.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Access token expired, will need to renewed\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              this.logger.info(\"OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n            cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);\n            cachedAccount = null;\n            if (cachedIdToken) {\n              idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);\n              localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;\n              accountInfo = {\n                homeAccountId: cachedIdToken.homeAccountId,\n                environment: cachedIdToken.environment,\n                tenantId: cachedIdToken.realm,\n                username: Constants.EMPTY_STRING,\n                localAccountId: localAccountId || Constants.EMPTY_STRING\n              };\n              cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\n            }\n            // increment telemetry cache hit counter\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n            return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {\n              account: cachedAccount,\n              accessToken: cachedAccessToken,\n              idToken: cachedIdToken,\n              refreshToken: null,\n              appMetadata: null\n            }, true, request, idTokenObject)];\n          case 1:\n            return [2 /*return*/, _c.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\r\n   * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.readIdTokenFromCacheForOBO = function (atHomeAccountId) {\n    var idTokenFilter = {\n      homeAccountId: atHomeAccountId,\n      environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.config.authOptions.clientId,\n      realm: this.authority.tenant\n    };\n    var idTokens = this.cacheManager.getIdTokensByFilter(idTokenFilter);\n    // When acquiring a token on behalf of an application, there might not be an id token in the cache\n    if (idTokens.length < 1) {\n      return null;\n    }\n    return idTokens[0];\n  };\n  /**\r\n   * Fetches the cached access token based on incoming assertion\r\n   * @param clientId\r\n   * @param request\r\n   * @param userAssertionHash\r\n   */\n  OnBehalfOfClient.prototype.readAccessTokenFromCacheForOBO = function (clientId, request) {\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      credentialType: credentialType,\n      clientId: clientId,\n      target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash,\n      userAssertionHash: this.userAssertionHash\n    };\n    var accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return accessTokens[0];\n  };\n  /**\r\n   * Make a network call to the server requesting credentials\r\n   * @param request\r\n   * @param authority\r\n   */\n  OnBehalfOfClient.prototype.executeTokenRequest = function (request, authority, userAssertionHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var queryParametersString, endpoint, requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            queryParametersString = this.createTokenQueryParameters(request);\n            endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\n            requestBody = this.createTokenRequestBody(request);\n            headers = this.createTokenRequestHeaders();\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: request.authority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4 /*yield*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\n            responseHandler.validateTokenResponse(response.body);\n            return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash)];\n          case 2:\n            tokenResponse = _a.sent();\n            return [2 /*return*/, tokenResponse];\n        }\n      });\n    });\n  };\n  /**\r\n   * generate a server request in accepable format\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.createTokenRequestBody = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n    parameterBuilder.addScopes(request.scopes);\n    parameterBuilder.addGrantType(GrantType.JWT_BEARER);\n    parameterBuilder.addClientInfo();\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId);\n    parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);\n    parameterBuilder.addOboAssertion(request.oboAssertion);\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      var clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(clientAssertion.assertion);\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    if (request.claims || this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0) {\n      parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\n    }\n    return parameterBuilder.createQueryString();\n  };\n  return OnBehalfOfClient;\n}(BaseClient);\nexport { OnBehalfOfClient };","map":{"version":3,"names":["__extends","__awaiter","__generator","BaseClient","RequestParameterBuilder","ScopeSet","AuthenticationScheme","CredentialType","GrantType","AADServerParamKeys","CacheOutcome","Constants","ResponseHandler","TimeUtils","AuthToken","ClientAuthError","UrlString","OnBehalfOfClient","_super","configuration","call","prototype","acquireToken","request","_a","_b","label","scopeSet","scopes","cryptoUtils","hashString","oboAssertion","userAssertionHash","sent","skipCache","executeTokenRequest","authority","trys","push","getCachedAuthenticationResult","cachedAccessToken","cachedIdToken","idTokenObject","cachedAccount","localAccountId","accountInfo","_c","readAccessTokenFromCacheForOBO","config","authOptions","clientId","serverTelemetryManager","setCacheOutcome","NO_CACHED_ACCESS_TOKEN","logger","info","createRefreshRequiredError","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","CACHED_ACCESS_TOKEN_EXPIRED","readIdTokenFromCacheForOBO","homeAccountId","secret","cryptoInterface","claims","oid","sub","environment","tenantId","realm","username","EMPTY_STRING","cacheManager","readAccountFromCache","incrementCacheHits","generateAuthenticationResult","account","accessToken","idToken","refreshToken","appMetadata","atHomeAccountId","idTokenFilter","canonicalAuthorityUrlComponents","HostNameAndPort","credentialType","ID_TOKEN","tenant","idTokens","getIdTokensByFilter","length","authScheme","authenticationScheme","BEARER","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","ACCESS_TOKEN","accessTokenFilter","target","createSearchScopes","asArray","tokenType","keyId","sshKid","requestedClaimsHash","accessTokens","getAccessTokensByFilter","numAccessTokens","createMultipleMatchingTokensInCacheError","queryParametersString","endpoint","requestBody","headers","thumbprint","reqTimestamp","response","responseHandler","tokenResponse","createTokenQueryParameters","appendQueryString","tokenEndpoint","createTokenRequestBody","createTokenRequestHeaders","resourceRequestMethod","resourceRequestUri","shrClaims","nowSeconds","executePostToTokenEndpoint","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","undefined","parameterBuilder","addClientId","addScopes","addGrantType","JWT_BEARER","addClientInfo","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","addServerTelemetry","correlationId","createNewGuid","addCorrelationId","addRequestTokenUse","ON_BEHALF_OF","addOboAssertion","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","clientCapabilities","addClaims","createQueryString"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-browser/node_modules/@azure/msal-common/dist/client/OnBehalfOfClient.js"],"sourcesContent":["/*! @azure/msal-common v13.1.0 2023-06-07 */\n'use strict';\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AuthenticationScheme, CredentialType, GrantType, AADServerParamKeys, CacheOutcome, Constants } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { UrlString } from '../url/UrlString.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * On-Behalf-Of client\r\n */\r\nvar OnBehalfOfClient = /** @class */ (function (_super) {\r\n    __extends(OnBehalfOfClient, _super);\r\n    function OnBehalfOfClient(configuration) {\r\n        return _super.call(this, configuration) || this;\r\n    }\r\n    /**\r\n     * Public API to acquire tokens with on behalf of flow\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.acquireToken = function (request) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        this.scopeSet = new ScopeSet(request.scopes || []);\r\n                        // generate the user_assertion_hash for OBOAssertion\r\n                        _a = this;\r\n                        return [4 /*yield*/, this.cryptoUtils.hashString(request.oboAssertion)];\r\n                    case 1:\r\n                        // generate the user_assertion_hash for OBOAssertion\r\n                        _a.userAssertionHash = _b.sent();\r\n                        if (!request.skipCache) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\r\n                    case 2: return [2 /*return*/, _b.sent()];\r\n                    case 3:\r\n                        _b.trys.push([3, 5, , 7]);\r\n                        return [4 /*yield*/, this.getCachedAuthenticationResult(request)];\r\n                    case 4: return [2 /*return*/, _b.sent()];\r\n                    case 5:\r\n                        _b.sent();\r\n                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\r\n                    case 6: \r\n                    // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\r\n                    return [2 /*return*/, _b.sent()];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * look up cache for tokens\r\n     * Find idtoken in the cache\r\n     * Find accessToken based on user assertion and account info in the cache\r\n     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\r\n     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.getCachedAuthenticationResult = function (request) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);\r\n                        if (!cachedAccessToken) {\r\n                            // Must refresh due to non-existent access_token.\r\n                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n                            this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\r\n                            throw ClientAuthError.createRefreshRequiredError();\r\n                        }\r\n                        else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\r\n                            // Access token expired, will need to renewed\r\n                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n                            this.logger.info(\"OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\r\n                            throw ClientAuthError.createRefreshRequiredError();\r\n                        }\r\n                        cachedIdToken = this.readIdTokenFromCacheForOBO(cachedAccessToken.homeAccountId);\r\n                        cachedAccount = null;\r\n                        if (cachedIdToken) {\r\n                            idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);\r\n                            localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;\r\n                            accountInfo = {\r\n                                homeAccountId: cachedIdToken.homeAccountId,\r\n                                environment: cachedIdToken.environment,\r\n                                tenantId: cachedIdToken.realm,\r\n                                username: Constants.EMPTY_STRING,\r\n                                localAccountId: localAccountId || Constants.EMPTY_STRING\r\n                            };\r\n                            cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\r\n                        }\r\n                        // increment telemetry cache hit counter\r\n                        if (this.config.serverTelemetryManager) {\r\n                            this.config.serverTelemetryManager.incrementCacheHits();\r\n                        }\r\n                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {\r\n                                account: cachedAccount,\r\n                                accessToken: cachedAccessToken,\r\n                                idToken: cachedIdToken,\r\n                                refreshToken: null,\r\n                                appMetadata: null\r\n                            }, true, request, idTokenObject)];\r\n                    case 1: return [2 /*return*/, _c.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\r\n     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.readIdTokenFromCacheForOBO = function (atHomeAccountId) {\r\n        var idTokenFilter = {\r\n            homeAccountId: atHomeAccountId,\r\n            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.config.authOptions.clientId,\r\n            realm: this.authority.tenant\r\n        };\r\n        var idTokens = this.cacheManager.getIdTokensByFilter(idTokenFilter);\r\n        // When acquiring a token on behalf of an application, there might not be an id token in the cache\r\n        if (idTokens.length < 1) {\r\n            return null;\r\n        }\r\n        return idTokens[0];\r\n    };\r\n    /**\r\n     * Fetches the cached access token based on incoming assertion\r\n     * @param clientId\r\n     * @param request\r\n     * @param userAssertionHash\r\n     */\r\n    OnBehalfOfClient.prototype.readAccessTokenFromCacheForOBO = function (clientId, request) {\r\n        var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        var credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n        var accessTokenFilter = {\r\n            credentialType: credentialType,\r\n            clientId: clientId,\r\n            target: ScopeSet.createSearchScopes(this.scopeSet.asArray()),\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n            userAssertionHash: this.userAssertionHash\r\n        };\r\n        var accessTokens = this.cacheManager.getAccessTokensByFilter(accessTokenFilter);\r\n        var numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return accessTokens[0];\r\n    };\r\n    /**\r\n     * Make a network call to the server requesting credentials\r\n     * @param request\r\n     * @param authority\r\n     */\r\n    OnBehalfOfClient.prototype.executeTokenRequest = function (request, authority, userAssertionHash) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var queryParametersString, endpoint, requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        queryParametersString = this.createTokenQueryParameters(request);\r\n                        endpoint = UrlString.appendQueryString(authority.tokenEndpoint, queryParametersString);\r\n                        requestBody = this.createTokenRequestBody(request);\r\n                        headers = this.createTokenRequestHeaders();\r\n                        thumbprint = {\r\n                            clientId: this.config.authOptions.clientId,\r\n                            authority: request.authority,\r\n                            scopes: request.scopes,\r\n                            claims: request.claims,\r\n                            authenticationScheme: request.authenticationScheme,\r\n                            resourceRequestMethod: request.resourceRequestMethod,\r\n                            resourceRequestUri: request.resourceRequestUri,\r\n                            shrClaims: request.shrClaims,\r\n                            sshKid: request.sshKid\r\n                        };\r\n                        reqTimestamp = TimeUtils.nowSeconds();\r\n                        return [4 /*yield*/, this.executePostToTokenEndpoint(endpoint, requestBody, headers, thumbprint)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n                        responseHandler.validateTokenResponse(response.body);\r\n                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash)];\r\n                    case 2:\r\n                        tokenResponse = _a.sent();\r\n                        return [2 /*return*/, tokenResponse];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * generate a server request in accepable format\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.createTokenRequestBody = function (request) {\r\n        var parameterBuilder = new RequestParameterBuilder();\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n        parameterBuilder.addScopes(request.scopes);\r\n        parameterBuilder.addGrantType(GrantType.JWT_BEARER);\r\n        parameterBuilder.addClientInfo();\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n        parameterBuilder.addThrottling();\r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n        parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);\r\n        parameterBuilder.addOboAssertion(request.oboAssertion);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            var clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n        if (request.claims || (this.config.authOptions.clientCapabilities && this.config.authOptions.clientCapabilities.length > 0)) {\r\n            parameterBuilder.addClaims(request.claims, this.config.authOptions.clientCapabilities);\r\n        }\r\n        return parameterBuilder.createQueryString();\r\n    };\r\n    return OnBehalfOfClient;\r\n}(BaseClient));\n\nexport { OnBehalfOfClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}