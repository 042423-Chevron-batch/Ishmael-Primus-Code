{"ast":null,"code":"\"use strict\";\n\nvar _asyncToGenerator = require(\"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _nativeDuplexpair = _interopRequireDefault(require(\"native-duplexpair\"));\nvar tls = _interopRequireWildcard(require(\"tls\"));\nvar _events = require(\"events\");\nvar _message = _interopRequireDefault(require(\"./message\"));\nvar _packet = require(\"./packet\");\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\nfunction _getRequireWildcardCache(nodeInterop) {\n  if (typeof WeakMap !== \"function\") return null;\n  var cacheBabelInterop = new WeakMap();\n  var cacheNodeInterop = new WeakMap();\n  return (_getRequireWildcardCache = function (nodeInterop) {\n    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;\n  })(nodeInterop);\n}\nfunction _interopRequireWildcard(obj, nodeInterop) {\n  if (!nodeInterop && obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n  var cache = _getRequireWildcardCache(nodeInterop);\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj.default = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = void 0;\n    this.debug = void 0;\n    this.tlsNegotiationComplete = void 0;\n    this.incomingMessageStream = void 0;\n    this.outgoingMessageStream = void 0;\n    this.securePair = void 0;\n    this.incomingMessageIterator = void 0;\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n    return this.outgoingMessageStream.packetSize;\n  } // Negotiate TLS encryption.\n\n  startTls(credentialsDetails, hostname, trustServerCertificate) {\n    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n      credentialsDetails.maxVersion = 'TLSv1.2';\n    }\n    const secureContext = tls.createSecureContext(credentialsDetails);\n    return new Promise((resolve, reject) => {\n      const duplexpair = new _nativeDuplexpair.default();\n      const securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1,\n          servername: hostname,\n          secureContext: secureContext,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      };\n      const onSecureConnect = () => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect); // If we encounter any errors from this point on,\n        // we just forward them to the actual network socket.\n\n        securePair.cleartext.once('error', err => {\n          this.socket.destroy(err);\n        });\n        const cipher = securePair.cleartext.getCipher();\n        if (cipher) {\n          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n        this.emit('secure', securePair.cleartext);\n        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n        this.outgoingMessageStream.unpipe(this.socket);\n        this.socket.unpipe(this.incomingMessageStream);\n        this.socket.pipe(securePair.encrypted);\n        securePair.encrypted.pipe(this.socket);\n        securePair.cleartext.pipe(this.incomingMessageStream);\n        this.outgoingMessageStream.pipe(securePair.cleartext);\n        this.tlsNegotiationComplete = true;\n        resolve();\n      };\n      const onError = err => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n        securePair.cleartext.destroy();\n        securePair.encrypted.destroy();\n        reject(err);\n      };\n      const onReadable = () => {\n        // When there is handshake data on the encryped stream of the secure pair,\n        // we wrap it into a `PRELOGIN` message and send it to the server.\n        //\n        // For each `PRELOGIN` message we sent we get back exactly one response message\n        // that contains the server's handshake response data.\n        const message = new _message.default({\n          type: _packet.TYPE.PRELOGIN,\n          resetConnection: false\n        });\n        let chunk;\n        while (chunk = securePair.encrypted.read()) {\n          message.write(chunk);\n        }\n        this.outgoingMessageStream.write(message);\n        message.end();\n        this.readMessage().then( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (response) {\n            // Setup readable handler for the next round of handshaking.\n            // If we encounter a `secureConnect` on the cleartext side\n            // of the secure pair, the `readable` handler is cleared\n            // and no further handshake handling will happen.\n            securePair.encrypted.once('readable', onReadable);\n            var _iteratorAbruptCompletion = false;\n            var _didIteratorError = false;\n            var _iteratorError;\n            try {\n              for (var _iterator = _asyncIterator(response), _step; _iteratorAbruptCompletion = !(_step = yield _iterator.next()).done; _iteratorAbruptCompletion = false) {\n                const data = _step.value;\n                {\n                  // We feed the server's handshake response back into the\n                  // encrypted end of the secure pair.\n                  securePair.encrypted.write(data);\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (_iteratorAbruptCompletion && _iterator.return != null) {\n                  yield _iterator.return();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()).catch(onError);\n      };\n      securePair.cleartext.once('error', onError);\n      securePair.cleartext.once('secureConnect', onSecureConnect);\n      securePair.encrypted.once('readable', onReadable);\n    });\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  }\n  /**\n   * Read the next incoming message from the socket.\n   */\n\n  readMessage() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this.incomingMessageIterator.next();\n      if (result.done) {\n        throw new Error('unexpected end of message stream');\n      }\n      return result.value;\n    })();\n  }\n}\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;","map":{"version":3,"names":["_asyncToGenerator","require","default","_asyncIterator","Object","defineProperty","exports","value","_nativeDuplexpair","_interopRequireDefault","tls","_interopRequireWildcard","_events","_message","_packet","_incomingMessageStream","_outgoingMessageStream","_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","obj","__esModule","cache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","MessageIO","EventEmitter","constructor","socket","packetSize","debug","tlsNegotiationComplete","incomingMessageStream","outgoingMessageStream","securePair","incomingMessageIterator","Symbol","asyncIterator","pipe","args","length","log","cleartext","setMaxSendFragment","startTls","credentialsDetails","hostname","trustServerCertificate","maxVersion","includes","secureContext","createSecureContext","Promise","resolve","reject","duplexpair","connect","socket1","servername","rejectUnauthorized","encrypted","socket2","onSecureConnect","removeListener","onReadable","onError","once","err","destroy","cipher","getCipher","name","version","emit","unpipe","message","type","TYPE","PRELOGIN","resetConnection","chunk","read","write","end","readMessage","then","_ref","response","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","_iterator","_step","next","done","data","return","_x","apply","arguments","catch","sendMessage","packetType","_this","result","Error","_default","module"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/tedious/lib/message-io.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _nativeDuplexpair = _interopRequireDefault(require(\"native-duplexpair\"));\n\nvar tls = _interopRequireWildcard(require(\"tls\"));\n\nvar _events = require(\"events\");\n\nvar _message = _interopRequireDefault(require(\"./message\"));\n\nvar _packet = require(\"./packet\");\n\nvar _incomingMessageStream = _interopRequireDefault(require(\"./incoming-message-stream\"));\n\nvar _outgoingMessageStream = _interopRequireDefault(require(\"./outgoing-message-stream\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nclass MessageIO extends _events.EventEmitter {\n  constructor(socket, packetSize, debug) {\n    super();\n    this.socket = void 0;\n    this.debug = void 0;\n    this.tlsNegotiationComplete = void 0;\n    this.incomingMessageStream = void 0;\n    this.outgoingMessageStream = void 0;\n    this.securePair = void 0;\n    this.incomingMessageIterator = void 0;\n    this.socket = socket;\n    this.debug = debug;\n    this.tlsNegotiationComplete = false;\n    this.incomingMessageStream = new _incomingMessageStream.default(this.debug);\n    this.incomingMessageIterator = this.incomingMessageStream[Symbol.asyncIterator]();\n    this.outgoingMessageStream = new _outgoingMessageStream.default(this.debug, {\n      packetSize: packetSize\n    });\n    this.socket.pipe(this.incomingMessageStream);\n    this.outgoingMessageStream.pipe(this.socket);\n  }\n\n  packetSize(...args) {\n    if (args.length > 0) {\n      const packetSize = args[0];\n      this.debug.log('Packet size changed from ' + this.outgoingMessageStream.packetSize + ' to ' + packetSize);\n      this.outgoingMessageStream.packetSize = packetSize;\n    }\n\n    if (this.securePair) {\n      this.securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n    }\n\n    return this.outgoingMessageStream.packetSize;\n  } // Negotiate TLS encryption.\n\n\n  startTls(credentialsDetails, hostname, trustServerCertificate) {\n    if (!credentialsDetails.maxVersion || !['TLSv1.2', 'TLSv1.1', 'TLSv1'].includes(credentialsDetails.maxVersion)) {\n      credentialsDetails.maxVersion = 'TLSv1.2';\n    }\n\n    const secureContext = tls.createSecureContext(credentialsDetails);\n    return new Promise((resolve, reject) => {\n      const duplexpair = new _nativeDuplexpair.default();\n      const securePair = this.securePair = {\n        cleartext: tls.connect({\n          socket: duplexpair.socket1,\n          servername: hostname,\n          secureContext: secureContext,\n          rejectUnauthorized: !trustServerCertificate\n        }),\n        encrypted: duplexpair.socket2\n      };\n\n      const onSecureConnect = () => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect); // If we encounter any errors from this point on,\n        // we just forward them to the actual network socket.\n\n        securePair.cleartext.once('error', err => {\n          this.socket.destroy(err);\n        });\n        const cipher = securePair.cleartext.getCipher();\n\n        if (cipher) {\n          this.debug.log('TLS negotiated (' + cipher.name + ', ' + cipher.version + ')');\n        }\n\n        this.emit('secure', securePair.cleartext);\n        securePair.cleartext.setMaxSendFragment(this.outgoingMessageStream.packetSize);\n        this.outgoingMessageStream.unpipe(this.socket);\n        this.socket.unpipe(this.incomingMessageStream);\n        this.socket.pipe(securePair.encrypted);\n        securePair.encrypted.pipe(this.socket);\n        securePair.cleartext.pipe(this.incomingMessageStream);\n        this.outgoingMessageStream.pipe(securePair.cleartext);\n        this.tlsNegotiationComplete = true;\n        resolve();\n      };\n\n      const onError = err => {\n        securePair.encrypted.removeListener('readable', onReadable);\n        securePair.cleartext.removeListener('error', onError);\n        securePair.cleartext.removeListener('secureConnect', onSecureConnect);\n        securePair.cleartext.destroy();\n        securePair.encrypted.destroy();\n        reject(err);\n      };\n\n      const onReadable = () => {\n        // When there is handshake data on the encryped stream of the secure pair,\n        // we wrap it into a `PRELOGIN` message and send it to the server.\n        //\n        // For each `PRELOGIN` message we sent we get back exactly one response message\n        // that contains the server's handshake response data.\n        const message = new _message.default({\n          type: _packet.TYPE.PRELOGIN,\n          resetConnection: false\n        });\n        let chunk;\n\n        while (chunk = securePair.encrypted.read()) {\n          message.write(chunk);\n        }\n\n        this.outgoingMessageStream.write(message);\n        message.end();\n        this.readMessage().then(async response => {\n          // Setup readable handler for the next round of handshaking.\n          // If we encounter a `secureConnect` on the cleartext side\n          // of the secure pair, the `readable` handler is cleared\n          // and no further handshake handling will happen.\n          securePair.encrypted.once('readable', onReadable);\n\n          for await (const data of response) {\n            // We feed the server's handshake response back into the\n            // encrypted end of the secure pair.\n            securePair.encrypted.write(data);\n          }\n        }).catch(onError);\n      };\n\n      securePair.cleartext.once('error', onError);\n      securePair.cleartext.once('secureConnect', onSecureConnect);\n      securePair.encrypted.once('readable', onReadable);\n    });\n  } // TODO listen for 'drain' event when socket.write returns false.\n  // TODO implement incomplete request cancelation (2.2.1.6)\n\n\n  sendMessage(packetType, data, resetConnection) {\n    const message = new _message.default({\n      type: packetType,\n      resetConnection: resetConnection\n    });\n    message.end(data);\n    this.outgoingMessageStream.write(message);\n    return message;\n  }\n  /**\n   * Read the next incoming message from the socket.\n   */\n\n\n  async readMessage() {\n    const result = await this.incomingMessageIterator.next();\n\n    if (result.done) {\n      throw new Error('unexpected end of message stream');\n    }\n\n    return result.value;\n  }\n\n}\n\nvar _default = MessageIO;\nexports.default = _default;\nmodule.exports = MessageIO;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}