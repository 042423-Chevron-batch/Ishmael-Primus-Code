{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __awaiter, __generator, __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, AuthenticationScheme, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\nvar CacheManager = /** @class */function () {\n  function CacheManager(clientId, cryptoImpl) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n    var currentAccounts = this.getAccountsFilteredBy();\n    var accountValues = Object.keys(currentAccounts).map(function (accountKey) {\n      return currentAccounts[accountKey];\n    });\n    var numAccounts = accountValues.length;\n    if (numAccounts < 1) {\n      return [];\n    } else {\n      var allAccounts = accountValues.map(function (value) {\n        var accountEntity = CacheManager.toObject(new AccountEntity(), value);\n        var accountInfo = accountEntity.getAccountInfo();\n        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\n        if (idToken && !accountInfo.idTokenClaims) {\n          accountInfo.idToken = idToken.secret;\n          accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\n        }\n        return accountInfo;\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!cacheRecord) {\n              throw ClientAuthError.createNullOrUndefinedCacheRecord();\n            }\n            if (!!cacheRecord.account) {\n              this.setAccount(cacheRecord.account);\n            }\n            if (!!cacheRecord.idToken) {\n              this.setIdTokenCredential(cacheRecord.idToken);\n            }\n            if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            if (!!cacheRecord.refreshToken) {\n              this.setRefreshTokenCredential(cacheRecord.refreshToken);\n            }\n            if (!!cacheRecord.appMetadata) {\n              this.setAppMetadata(cacheRecord.appMetadata);\n            }\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            currentTokenCache = this.getCredentialsFilteredBy({\n              clientId: credential.clientId,\n              credentialType: credential.credentialType,\n              environment: credential.environment,\n              homeAccountId: credential.homeAccountId,\n              realm: credential.realm,\n              tokenType: credential.tokenType,\n              requestedClaimsHash: credential.requestedClaimsHash\n            });\n            currentScopes = ScopeSet.fromString(credential.target);\n            currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) {\n              return currentTokenCache.accessTokens[key];\n            });\n            if (!currentAccessTokens) return [3 /*break*/, 2];\n            removedAccessTokens_1 = [];\n            currentAccessTokens.forEach(function (tokenEntity) {\n              var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\n              if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedAccessTokens_1)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            this.setAccessTokenCredential(credential);\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n  CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm, nativeAccountId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAccounts = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n      if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {\n        return;\n      }\n      matchingAccounts[cacheKey] = entity;\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n  CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\n    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);\n  };\n  /**\r\n   * Support function to help match credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   * @param userAssertionHash\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingCredentials = {\n      idTokens: {},\n      accessTokens: {},\n      refreshTokens: {}\n    };\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity.getCredentialType(cacheKey);\n      if (credType === Constants.NOT_DEFINED) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getSpecificCredential(cacheKey, credType);\n      if (!entity) {\n        return;\n      }\n      if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {\n        return;\n      }\n      /*\r\n       * homeAccountId can undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n       * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n       */\n      if (typeof homeAccountId === \"string\" && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\n        return;\n      }\n      /*\r\n       * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n       * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n       */\n      if (!!target && !_this.matchTarget(entity, target)) {\n        return;\n      }\n      // If request OR cached entity has requested Claims Hash, check if they match\n      if (requestedClaimsHash || entity.requestedClaimsHash) {\n        // Don't match if either is undefined or they are different\n        if (entity.requestedClaimsHash !== requestedClaimsHash) {\n          return;\n        }\n      }\n      // Access Token with Auth Scheme specific matching\n      if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\n        if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {\n          return;\n        }\n        // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\n        if (tokenType === AuthenticationScheme.SSH) {\n          if (keyId && !_this.matchKeyId(entity, keyId)) {\n            return;\n          }\n        }\n      }\n      // At this point, the entity matches the request, update cache key if key schema has changed\n      var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);\n      switch (credType) {\n        case CredentialType.ID_TOKEN:\n          matchingCredentials.idTokens[updatedCacheKey] = entity;\n          break;\n        case CredentialType.ACCESS_TOKEN:\n        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n          matchingCredentials.accessTokens[updatedCacheKey] = entity;\n          break;\n        case CredentialType.REFRESH_TOKEN:\n          matchingCredentials.refreshTokens[updatedCacheKey] = entity;\n          break;\n      }\n    });\n    return matchingCredentials;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAppMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      }\n      // Attempt retrieval\n      var entity = _this.getAuthorityMetadata(cacheKey);\n      if (!entity) {\n        return;\n      }\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n  CacheManager.prototype.removeAllAccounts = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, removedAccounts;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            removedAccounts = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              var entity = _this.getAccount(cacheKey);\n              if (!entity) {\n                return;\n              }\n              removedAccounts.push(_this.removeAccount(cacheKey));\n            });\n            return [4 /*yield*/, Promise.all(removedAccounts)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    return __awaiter(this, void 0, void 0, function () {\n      var account;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            account = this.getAccount(accountKey);\n            if (!account) {\n              throw ClientAuthError.createNoAccountFoundError();\n            }\n            return [4 /*yield*/, this.removeAccountContext(account)];\n          case 1:\n            return [2 /*return*/, _a.sent() && this.removeItem(accountKey, CacheSchemaType.ACCOUNT)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes credentials associated with the provided account\r\n   * @param account\r\n   */\n  CacheManager.prototype.removeAccountContext = function (account) {\n    return __awaiter(this, void 0, void 0, function () {\n      var allCacheKeys, accountId, removedCredentials;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            allCacheKeys = this.getKeys();\n            accountId = account.generateAccountId();\n            removedCredentials = [];\n            allCacheKeys.forEach(function (cacheKey) {\n              // don't parse any non-credential type cache entities\n              var credType = CredentialEntity.getCredentialType(cacheKey);\n              if (credType === Constants.NOT_DEFINED) {\n                return;\n              }\n              var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\n              if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n                removedCredentials.push(_this.removeCredential(cacheEntity));\n              }\n            });\n            return [4 /*yield*/, Promise.all(removedCredentials)];\n          case 1:\n            _a.sent();\n            return [2 /*return*/, true];\n        }\n      });\n    });\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n  CacheManager.prototype.removeCredential = function (credential) {\n    return __awaiter(this, void 0, void 0, function () {\n      var key, accessTokenWithAuthSchemeEntity, kid;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            key = credential.generateCredentialKey();\n            if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];\n            if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];\n            accessTokenWithAuthSchemeEntity = credential;\n            kid = accessTokenWithAuthSchemeEntity.keyId;\n            if (!kid) return [3 /*break*/, 4];\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            _a.sent();\n            throw ClientAuthError.createBindingKeyNotRemovedError();\n          case 4:\n            return [2 /*return*/, this.removeItem(key, CacheSchemaType.CREDENTIAL)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readCacheRecord = function (account, clientId, request, environment) {\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.readIdTokenFromCache(clientId, account);\n    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\n    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param nativeAccountId\r\n   * @returns AccountEntity or Null\r\n   */\n  CacheManager.prototype.readAccountFromCacheWithNativeAccountId = function (nativeAccountId) {\n    // fetch account from memory\n    var accountFilter = {\n      nativeAccountId: nativeAccountId\n    };\n    var accountCache = this.getAccountsFilteredBy(accountFilter);\n    var accounts = Object.keys(accountCache).map(function (key) {\n      return accountCache[key];\n    });\n    if (accounts.length < 1) {\n      return null;\n    } else if (accounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return accountCache[0];\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n  CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: clientId,\n      realm: account.tenantId\n    };\n    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    var numIdTokens = idTokens.length;\n    if (numIdTokens < 1) {\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return idTokens[0];\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n  CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, request) {\n    var scopes = new ScopeSet(request.scopes || []);\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: clientId,\n      realm: account.tenantId,\n      target: scopes.printScopesLowerCase(),\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash\n    };\n    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return accessTokens[0];\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n  CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: clientId,\n      familyId: id\n    };\n    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) {\n      return credentialCache.refreshTokens[key];\n    });\n    var numRefreshTokens = refreshTokens.length;\n    if (numRefreshTokens < 1) {\n      return null;\n    }\n    // address the else case after remove functions address environment aliases\n    return refreshTokens[0];\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n  CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\n    }\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\n    var appMetadata = this.readAppMetadataFromCache(environment, clientId);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(typeof entity.homeAccountId === \"string\" && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n  CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\n    return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * helper to match nativeAccountId\r\n   * @param entity\r\n   * @param nativeAccountId\r\n   * @returns boolean indicating the match result\r\n   */\n  CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\n    return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n    var entityScopeSet = ScopeSet.fromString(entity.target);\n    var requestTargetScopeSet = ScopeSet.fromString(target);\n    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n      requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n    } else {\n      requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\n    }\n    return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n  };\n  /**\r\n   * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchTokenType = function (entity, tokenType) {\n    return !!(entity.tokenType && entity.tokenType === tokenType);\n  };\n  /**\r\n   * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n   * @param entity\r\n   * @param tokenType\r\n   */\n  CacheManager.prototype.matchKeyId = function (entity, keyId) {\n    return !!(entity.keyId && entity.keyId === keyId);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n   * @param key\r\n   * @param credType\r\n   */\n  CacheManager.prototype.getSpecificCredential = function (key, credType) {\n    switch (credType) {\n      case CredentialType.ID_TOKEN:\n        {\n          return this.getIdTokenCredential(key);\n        }\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        {\n          return this.getAccessTokenCredential(key);\n        }\n      case CredentialType.REFRESH_TOKEN:\n        {\n          return this.getRefreshTokenCredential(key);\n        }\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n    return obj;\n  };\n  return CacheManager;\n}();\nvar DefaultStorageClass = /** @class */function (_super) {\n  __extends(DefaultStorageClass, _super);\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  DefaultStorageClass.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var notImplErr;\n      return __generator(this, function (_a) {\n        notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n        throw AuthError.createUnexpectedError(notImplErr);\n      });\n    });\n  };\n  DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\n    var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError.createUnexpectedError(notImplErr);\n  };\n  return DefaultStorageClass;\n}(CacheManager);\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"names":["__awaiter","__generator","__extends","Constants","CredentialType","AuthenticationScheme","CacheSchemaType","THE_FAMILY_ID","APP_METADATA","AUTHORITY_METADATA_CONSTANTS","CredentialEntity","ScopeSet","AccountEntity","AuthError","ClientAuthError","AuthToken","CacheManager","clientId","cryptoImpl","prototype","getAllAccounts","_this","currentAccounts","getAccountsFilteredBy","accountValues","Object","keys","map","accountKey","numAccounts","length","allAccounts","value","accountEntity","toObject","accountInfo","getAccountInfo","idToken","readIdTokenFromCache","idTokenClaims","secret","claims","saveCacheRecord","cacheRecord","_a","label","createNullOrUndefinedCacheRecord","account","setAccount","setIdTokenCredential","accessToken","saveAccessToken","sent","refreshToken","setRefreshTokenCredential","appMetadata","setAppMetadata","credential","currentTokenCache","currentScopes","currentAccessTokens","removedAccessTokens_1","getCredentialsFilteredBy","credentialType","environment","homeAccountId","realm","tokenType","requestedClaimsHash","fromString","target","accessTokens","key","forEach","tokenEntity","tokenScopeSet","intersectingScopeSets","push","removeCredential","Promise","all","setAccessTokenCredential","accountFilter","getAccountsFilteredByInternal","EMPTY_STRING","nativeAccountId","allCacheKeys","getKeys","matchingAccounts","cacheKey","entity","getAccount","matchHomeAccountId","matchEnvironment","matchRealm","matchNativeAccountId","filter","getCredentialsFilteredByInternal","familyId","userAssertionHash","keyId","matchingCredentials","idTokens","refreshTokens","credType","getCredentialType","NOT_DEFINED","getSpecificCredential","matchUserAssertionHash","matchCredentialType","matchClientId","matchFamilyId","matchTarget","ACCESS_TOKEN_WITH_AUTH_SCHEME","matchTokenType","SSH","matchKeyId","updatedCacheKey","updateCredentialCacheKey","ID_TOKEN","ACCESS_TOKEN","REFRESH_TOKEN","getAppMetadataFilteredBy","getAppMetadataFilteredByInternal","matchingAppMetadata","isAppMetadata","getAppMetadata","getAuthorityMetadataByAlias","host","getAuthorityMetadataKeys","matchedEntity","isAuthorityMetadata","indexOf","getAuthorityMetadata","aliases","removeAllAccounts","removedAccounts","removeAccount","createNoAccountFoundError","removeAccountContext","removeItem","ACCOUNT","accountId","removedCredentials","generateAccountId","cacheEntity","accessTokenWithAuthSchemeEntity","kid","generateCredentialKey","toLowerCase","POP","trys","removeTokenBindingKey","createBindingKeyNotRemovedError","CREDENTIAL","removeAppMetadata","readCacheRecord","request","cachedAccount","readAccountFromCache","cachedIdToken","cachedAccessToken","readAccessTokenFromCache","cachedRefreshToken","readRefreshTokenFromCache","cachedAppMetadata","readAppMetadataFromCache","generateAccountCacheKey","readAccountFromCacheWithNativeAccountId","accountCache","accounts","createMultipleMatchingAccountsInCacheError","idTokenFilter","tenantId","credentialCache","numIdTokens","createMultipleMatchingTokensInCacheError","scopes","authScheme","authenticationScheme","BEARER","accessTokenFilter","printScopesLowerCase","sshKid","numAccessTokens","familyRT","id","undefined","refreshTokenFilter","numRefreshTokens","appMetadataFilter","appMetadataEntries","numAppMetadata","createMultipleMatchingAppMetadataInCacheError","isAppMetadataFOCI","cloudMetadata","isNotAccessTokenCredential","entityScopeSet","requestTargetScopeSet","containsOnlyOIDCScopes","removeOIDCScopes","removeScope","OFFLINE_ACCESS_SCOPE","containsScopeSet","CACHE_KEY","generateAuthorityMetadataCacheKey","authority","getIdTokenCredential","getAccessTokenCredential","getRefreshTokenCredential","obj","json","propertyName","DefaultStorageClass","_super","apply","arguments","notImplErr","createUnexpectedError","setServerTelemetry","getServerTelemetry","setAuthorityMetadata","setThrottlingCache","getThrottlingCache","containsKey","clear"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-common/dist/cache/CacheManager.js"],"sourcesContent":["/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\nimport { __awaiter, __generator, __extends } from '../_virtual/_tslib.js';\nimport { Constants, CredentialType, AuthenticationScheme, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS } from '../utils/Constants.js';\nimport { CredentialEntity } from './entities/CredentialEntity.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AccountEntity } from './entities/AccountEntity.js';\nimport { AuthError } from '../error/AuthError.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\nimport { AuthToken } from '../account/AuthToken.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nvar CacheManager = /** @class */ (function () {\r\n    function CacheManager(clientId, cryptoImpl) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n    }\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    CacheManager.prototype.getAllAccounts = function () {\r\n        var _this = this;\r\n        var currentAccounts = this.getAccountsFilteredBy();\r\n        var accountValues = Object.keys(currentAccounts).map(function (accountKey) { return currentAccounts[accountKey]; });\r\n        var numAccounts = accountValues.length;\r\n        if (numAccounts < 1) {\r\n            return [];\r\n        }\r\n        else {\r\n            var allAccounts = accountValues.map(function (value) {\r\n                var accountEntity = CacheManager.toObject(new AccountEntity(), value);\r\n                var accountInfo = accountEntity.getAccountInfo();\r\n                var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\r\n                if (idToken && !accountInfo.idTokenClaims) {\r\n                    accountInfo.idToken = idToken.secret;\r\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, _this.cryptoImpl).claims;\r\n                }\r\n                return accountInfo;\r\n            });\r\n            return allAccounts;\r\n        }\r\n    };\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        if (!cacheRecord) {\r\n                            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n                        }\r\n                        if (!!cacheRecord.account) {\r\n                            this.setAccount(cacheRecord.account);\r\n                        }\r\n                        if (!!cacheRecord.idToken) {\r\n                            this.setIdTokenCredential(cacheRecord.idToken);\r\n                        }\r\n                        if (!!!cacheRecord.accessToken) return [3 /*break*/, 2];\r\n                        return [4 /*yield*/, this.saveAccessToken(cacheRecord.accessToken)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        if (!!cacheRecord.refreshToken) {\r\n                            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n                        }\r\n                        if (!!cacheRecord.appMetadata) {\r\n                            this.setAppMetadata(cacheRecord.appMetadata);\r\n                        }\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    CacheManager.prototype.saveAccessToken = function (credential) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var currentTokenCache, currentScopes, currentAccessTokens, removedAccessTokens_1;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        currentTokenCache = this.getCredentialsFilteredBy({\r\n                            clientId: credential.clientId,\r\n                            credentialType: credential.credentialType,\r\n                            environment: credential.environment,\r\n                            homeAccountId: credential.homeAccountId,\r\n                            realm: credential.realm,\r\n                            tokenType: credential.tokenType,\r\n                            requestedClaimsHash: credential.requestedClaimsHash\r\n                        });\r\n                        currentScopes = ScopeSet.fromString(credential.target);\r\n                        currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) { return currentTokenCache.accessTokens[key]; });\r\n                        if (!currentAccessTokens) return [3 /*break*/, 2];\r\n                        removedAccessTokens_1 = [];\r\n                        currentAccessTokens.forEach(function (tokenEntity) {\r\n                            var tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                            if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                                removedAccessTokens_1.push(_this.removeCredential(tokenEntity));\r\n                            }\r\n                        });\r\n                        return [4 /*yield*/, Promise.all(removedAccessTokens_1)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        _a.label = 2;\r\n                    case 2:\r\n                        this.setAccessTokenCredential(credential);\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\r\n        return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : Constants.EMPTY_STRING, accountFilter ? accountFilter.environment : Constants.EMPTY_STRING, accountFilter ? accountFilter.realm : Constants.EMPTY_STRING, accountFilter ? accountFilter.nativeAccountId : Constants.EMPTY_STRING);\r\n    };\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm, nativeAccountId) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingAccounts = {};\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            var entity = _this.getAccount(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!realm && !_this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n            if (!!nativeAccountId && !_this.matchNativeAccountId(entity, nativeAccountId)) {\r\n                return;\r\n            }\r\n            matchingAccounts[cacheKey] = entity;\r\n        });\r\n        return matchingAccounts;\r\n    };\r\n    /**\r\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\r\n        return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.userAssertionHash, filter.tokenType, filter.keyId, filter.requestedClaimsHash);\r\n    };\r\n    /**\r\n     * Support function to help match credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     * @param userAssertionHash\r\n     * @param tokenType\r\n     */\r\n    CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, userAssertionHash, tokenType, keyId, requestedClaimsHash) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingCredentials = {\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n        };\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-credential type cache entities\r\n            var credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getSpecificCredential(cacheKey, credType);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!userAssertionHash && !_this.matchUserAssertionHash(entity, userAssertionHash)) {\r\n                return;\r\n            }\r\n            /*\r\n             * homeAccountId can undefined, and we want to filter out cached items that have a homeAccountId of \"\"\r\n             * because we don't want a client_credential request to return a cached token that has a homeAccountId\r\n             */\r\n            if ((typeof homeAccountId === \"string\") && !_this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!realm && !_this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n            if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\r\n                return;\r\n            }\r\n            if (!!clientId && !_this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n            if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\r\n                return;\r\n            }\r\n            /*\r\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n             */\r\n            if (!!target && !_this.matchTarget(entity, target)) {\r\n                return;\r\n            }\r\n            // If request OR cached entity has requested Claims Hash, check if they match\r\n            if (requestedClaimsHash || entity.requestedClaimsHash) {\r\n                // Don't match if either is undefined or they are different\r\n                if (entity.requestedClaimsHash !== requestedClaimsHash) {\r\n                    return;\r\n                }\r\n            }\r\n            // Access Token with Auth Scheme specific matching\r\n            if (credentialType === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME) {\r\n                if (!!tokenType && !_this.matchTokenType(entity, tokenType)) {\r\n                    return;\r\n                }\r\n                // KeyId (sshKid) in request must match cached SSH certificate keyId because SSH cert is bound to a specific key\r\n                if (tokenType === AuthenticationScheme.SSH) {\r\n                    if (keyId && !_this.matchKeyId(entity, keyId)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            // At this point, the entity matches the request, update cache key if key schema has changed\r\n            var updatedCacheKey = _this.updateCredentialCacheKey(cacheKey, entity);\r\n            switch (credType) {\r\n                case CredentialType.ID_TOKEN:\r\n                    matchingCredentials.idTokens[updatedCacheKey] = entity;\r\n                    break;\r\n                case CredentialType.ACCESS_TOKEN:\r\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                    matchingCredentials.accessTokens[updatedCacheKey] = entity;\r\n                    break;\r\n                case CredentialType.REFRESH_TOKEN:\r\n                    matchingCredentials.refreshTokens[updatedCacheKey] = entity;\r\n                    break;\r\n            }\r\n        });\r\n        return matchingCredentials;\r\n    };\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\r\n        return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\r\n    };\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        var matchingAppMetadata = {};\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!_this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getAppMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (!!environment && !_this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n            if (!!clientId && !_this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n            matchingAppMetadata[cacheKey] = entity;\r\n        });\r\n        return matchingAppMetadata;\r\n    };\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\r\n        var _this = this;\r\n        var allCacheKeys = this.getAuthorityMetadataKeys();\r\n        var matchedEntity = null;\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\r\n                return;\r\n            }\r\n            // Attempt retrieval\r\n            var entity = _this.getAuthorityMetadata(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n            matchedEntity = entity;\r\n        });\r\n        return matchedEntity;\r\n    };\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    CacheManager.prototype.removeAllAccounts = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var allCacheKeys, removedAccounts;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        allCacheKeys = this.getKeys();\r\n                        removedAccounts = [];\r\n                        allCacheKeys.forEach(function (cacheKey) {\r\n                            var entity = _this.getAccount(cacheKey);\r\n                            if (!entity) {\r\n                                return;\r\n                            }\r\n                            removedAccounts.push(_this.removeAccount(cacheKey));\r\n                        });\r\n                        return [4 /*yield*/, Promise.all(removedAccounts)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.removeAccount = function (accountKey) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var account;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        account = this.getAccount(accountKey);\r\n                        if (!account) {\r\n                            throw ClientAuthError.createNoAccountFoundError();\r\n                        }\r\n                        return [4 /*yield*/, this.removeAccountContext(account)];\r\n                    case 1: return [2 /*return*/, ((_a.sent()) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT))];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes credentials associated with the provided account\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.removeAccountContext = function (account) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var allCacheKeys, accountId, removedCredentials;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        allCacheKeys = this.getKeys();\r\n                        accountId = account.generateAccountId();\r\n                        removedCredentials = [];\r\n                        allCacheKeys.forEach(function (cacheKey) {\r\n                            // don't parse any non-credential type cache entities\r\n                            var credType = CredentialEntity.getCredentialType(cacheKey);\r\n                            if (credType === Constants.NOT_DEFINED) {\r\n                                return;\r\n                            }\r\n                            var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\r\n                            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\r\n                                removedCredentials.push(_this.removeCredential(cacheEntity));\r\n                            }\r\n                        });\r\n                        return [4 /*yield*/, Promise.all(removedCredentials)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    CacheManager.prototype.removeCredential = function (credential) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var key, accessTokenWithAuthSchemeEntity, kid;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        key = credential.generateCredentialKey();\r\n                        if (!(credential.credentialType.toLowerCase() === CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME.toLowerCase())) return [3 /*break*/, 4];\r\n                        if (!(credential.tokenType === AuthenticationScheme.POP)) return [3 /*break*/, 4];\r\n                        accessTokenWithAuthSchemeEntity = credential;\r\n                        kid = accessTokenWithAuthSchemeEntity.keyId;\r\n                        if (!kid) return [3 /*break*/, 4];\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        _a.trys.push([1, 3, , 4]);\r\n                        return [4 /*yield*/, this.cryptoImpl.removeTokenBindingKey(kid)];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [3 /*break*/, 4];\r\n                    case 3:\r\n                        _a.sent();\r\n                        throw ClientAuthError.createBindingKeyNotRemovedError();\r\n                    case 4: return [2 /*return*/, this.removeItem(key, CacheSchemaType.CREDENTIAL)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    CacheManager.prototype.removeAppMetadata = function () {\r\n        var _this = this;\r\n        var allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach(function (cacheKey) {\r\n            if (_this.isAppMetadata(cacheKey)) {\r\n                _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\r\n            }\r\n        });\r\n        return true;\r\n    };\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    CacheManager.prototype.readCacheRecord = function (account, clientId, request, environment) {\r\n        var cachedAccount = this.readAccountFromCache(account);\r\n        var cachedIdToken = this.readIdTokenFromCache(clientId, account);\r\n        var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, request);\r\n        var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\r\n        var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    };\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    CacheManager.prototype.readAccountFromCache = function (account) {\r\n        var accountKey = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    };\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param nativeAccountId\r\n     * @returns AccountEntity or Null\r\n     */\r\n    CacheManager.prototype.readAccountFromCacheWithNativeAccountId = function (nativeAccountId) {\r\n        // fetch account from memory\r\n        var accountFilter = {\r\n            nativeAccountId: nativeAccountId\r\n        };\r\n        var accountCache = this.getAccountsFilteredBy(accountFilter);\r\n        var accounts = Object.keys(accountCache).map(function (key) { return accountCache[key]; });\r\n        if (accounts.length < 1) {\r\n            return null;\r\n        }\r\n        else if (accounts.length > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\r\n        }\r\n        return accountCache[0];\r\n    };\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\r\n        var idTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\r\n        var idTokens = Object.keys(credentialCache.idTokens).map(function (key) { return credentialCache.idTokens[key]; });\r\n        var numIdTokens = idTokens.length;\r\n        if (numIdTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numIdTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return idTokens[0];\r\n    };\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, request) {\r\n        var scopes = new ScopeSet(request.scopes || []);\r\n        var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        var credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n        var accessTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n            target: scopes.printScopesLowerCase(),\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\r\n        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });\r\n        var numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return accessTokens[0];\r\n    };\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\r\n        var id = familyRT ? THE_FAMILY_ID : undefined;\r\n        var refreshTokenFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: clientId,\r\n            familyId: id,\r\n        };\r\n        var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\r\n        var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) { return credentialCache.refreshTokens[key]; });\r\n        var numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n        return refreshTokens[0];\r\n    };\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\r\n        var appMetadataFilter = {\r\n            environment: environment,\r\n            clientId: clientId,\r\n        };\r\n        var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        var appMetadataEntries = Object.keys(appMetadata).map(function (key) { return appMetadata[key]; });\r\n        var numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        }\r\n        else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n        return appMetadataEntries[0];\r\n    };\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\r\n        var appMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    };\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\r\n        return !!((typeof entity.homeAccountId === \"string\") && (homeAccountId === entity.homeAccountId));\r\n    };\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    CacheManager.prototype.matchUserAssertionHash = function (entity, userAssertionHash) {\r\n        return !!(entity.userAssertionHash && userAssertionHash === entity.userAssertionHash);\r\n    };\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    CacheManager.prototype.matchEnvironment = function (entity, environment) {\r\n        var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    };\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    CacheManager.prototype.matchClientId = function (entity, clientId) {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    };\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    CacheManager.prototype.matchFamilyId = function (entity, familyId) {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    };\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    CacheManager.prototype.matchRealm = function (entity, realm) {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    };\r\n    /**\r\n     * helper to match nativeAccountId\r\n     * @param entity\r\n     * @param nativeAccountId\r\n     * @returns boolean indicating the match result\r\n     */\r\n    CacheManager.prototype.matchNativeAccountId = function (entity, nativeAccountId) {\r\n        return !!(entity.nativeAccountId && nativeAccountId === entity.nativeAccountId);\r\n    };\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    CacheManager.prototype.matchTarget = function (entity, target) {\r\n        var isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n        if (isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n        var entityScopeSet = ScopeSet.fromString(entity.target);\r\n        var requestTargetScopeSet = ScopeSet.fromString(target);\r\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\r\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\r\n        }\r\n        else {\r\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\r\n        }\r\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\r\n    };\r\n    /**\r\n     * Returns true if the credential's tokenType or Authentication Scheme matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    CacheManager.prototype.matchTokenType = function (entity, tokenType) {\r\n        return !!(entity.tokenType && entity.tokenType === tokenType);\r\n    };\r\n    /**\r\n     * Returns true if the credential's keyId matches the one in the request, false otherwise\r\n     * @param entity\r\n     * @param tokenType\r\n     */\r\n    CacheManager.prototype.matchKeyId = function (entity, keyId) {\r\n        return !!(entity.keyId && entity.keyId === keyId);\r\n    };\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    CacheManager.prototype.isAppMetadata = function (key) {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    };\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    CacheManager.prototype.isAuthorityMetadata = function (key) {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    };\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\r\n        return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\r\n    };\r\n    /**\r\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n     * @param key\r\n     * @param credType\r\n     */\r\n    CacheManager.prototype.getSpecificCredential = function (key, credType) {\r\n        switch (credType) {\r\n            case CredentialType.ID_TOKEN: {\r\n                return this.getIdTokenCredential(key);\r\n            }\r\n            case CredentialType.ACCESS_TOKEN:\r\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\r\n                return this.getAccessTokenCredential(key);\r\n            }\r\n            case CredentialType.REFRESH_TOKEN: {\r\n                return this.getRefreshTokenCredential(key);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    };\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    CacheManager.toObject = function (obj, json) {\r\n        for (var propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    };\r\n    return CacheManager;\r\n}());\r\nvar DefaultStorageClass = /** @class */ (function (_super) {\r\n    __extends(DefaultStorageClass, _super);\r\n    function DefaultStorageClass() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    DefaultStorageClass.prototype.setAccount = function () {\r\n        var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAccount = function () {\r\n        var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setIdTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getIdTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAccessTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAccessTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\r\n        var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAppMetadata = function () {\r\n        var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAppMetadata = function () {\r\n        var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setServerTelemetry = function () {\r\n        var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getServerTelemetry = function () {\r\n        var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setAuthorityMetadata = function () {\r\n        var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAuthorityMetadata = function () {\r\n        var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\r\n        var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.setThrottlingCache = function () {\r\n        var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getThrottlingCache = function () {\r\n        var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.removeItem = function () {\r\n        var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.containsKey = function () {\r\n        var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.getKeys = function () {\r\n        var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    DefaultStorageClass.prototype.clear = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var notImplErr;\r\n            return __generator(this, function (_a) {\r\n                notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n                throw AuthError.createUnexpectedError(notImplErr);\r\n            });\r\n        });\r\n    };\r\n    DefaultStorageClass.prototype.updateCredentialCacheKey = function () {\r\n        var notImplErr = \"Storage interface - updateCredentialCacheKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    };\r\n    return DefaultStorageClass;\r\n}(CacheManager));\n\nexport { CacheManager, DefaultStorageClass };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}