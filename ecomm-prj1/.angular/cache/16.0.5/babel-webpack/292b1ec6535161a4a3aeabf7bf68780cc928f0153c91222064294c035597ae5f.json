{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n  DefaultScope: \"/.default\",\n  /**\n   * Defines constants for use with HTTP headers.\n   */\n  HeaderConstants: {\n    /**\n     * The Authorization header.\n     */\n    AUTHORIZATION: \"authorization\"\n  }\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (challengeOptions) {\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n    if (challenge) {\n      const challengeInfo = parseChallenge(challenge);\n      const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n      const tenantId = extractTenantId(challengeInfo);\n      const accessToken = yield challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), {\n        tenantId\n      }));\n      if (!accessToken) {\n        return false;\n      }\n      challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n      return true;\n    }\n    return false;\n  });\n  return function authorizeRequestOnTenantChallenge(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n  const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n  const pathSegments = parsedAuthUri.pathname.split(\"/\");\n  const tenantId = pathSegments[1];\n  return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n  if (!challengeInfo.resource_uri) {\n    return challengeOptions.scopes;\n  }\n  const challengeScopes = new URL(challengeInfo.resource_uri);\n  challengeScopes.pathname = Constants.DefaultScope;\n  return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n  const challenge = response.headers.get(\"WWW-Authenticate\");\n  if (response.status === 401 && challenge) {\n    return challenge;\n  }\n  return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n  const bearerChallenge = challenge.slice(\"Bearer \".length);\n  const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter(x => x);\n  const keyValuePairs = challengeParts.map(keyValue => (([key, value]) => ({\n    [key]: value\n  }))(keyValue.trim().split(\"=\")));\n  // Key-value pairs to plain object:\n  return keyValuePairs.reduce((a, b) => Object.assign(Object.assign({}, a), b), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n  return {\n    abortSignal: request.abortSignal,\n    requestOptions: {\n      timeout: request.timeout\n    },\n    tracingOptions: request.tracingOptions\n  };\n}","map":{"version":3,"names":["Constants","DefaultScope","HeaderConstants","AUTHORIZATION","authorizeRequestOnTenantChallenge","_ref","_asyncToGenerator","challengeOptions","requestOptions","requestToOptions","request","challenge","getChallenge","response","challengeInfo","parseChallenge","challengeScopes","buildScopes","tenantId","extractTenantId","accessToken","getAccessToken","Object","assign","headers","set","token","_x","apply","arguments","parsedAuthUri","URL","authorization_uri","pathSegments","pathname","split","resource_uri","scopes","toString","get","status","bearerChallenge","slice","length","challengeParts","trim","filter","x","keyValuePairs","map","keyValue","key","value","reduce","a","b","abortSignal","timeout","tracingOptions"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/core-client/dist-esm/src/authorizeRequestOnTenantChallenge.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/**\n * A set of constants used internally when processing requests.\n */\nconst Constants = {\n    DefaultScope: \"/.default\",\n    /**\n     * Defines constants for use with HTTP headers.\n     */\n    HeaderConstants: {\n        /**\n         * The Authorization header.\n         */\n        AUTHORIZATION: \"authorization\",\n    },\n};\n/**\n * Defines a callback to handle auth challenge for Storage APIs.\n * This implements the bearer challenge process described here: https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory#bearer-challenge\n * Handling has specific features for storage that departs to the general AAD challenge docs.\n **/\nexport const authorizeRequestOnTenantChallenge = async (challengeOptions) => {\n    const requestOptions = requestToOptions(challengeOptions.request);\n    const challenge = getChallenge(challengeOptions.response);\n    if (challenge) {\n        const challengeInfo = parseChallenge(challenge);\n        const challengeScopes = buildScopes(challengeOptions, challengeInfo);\n        const tenantId = extractTenantId(challengeInfo);\n        const accessToken = await challengeOptions.getAccessToken(challengeScopes, Object.assign(Object.assign({}, requestOptions), { tenantId }));\n        if (!accessToken) {\n            return false;\n        }\n        challengeOptions.request.headers.set(Constants.HeaderConstants.AUTHORIZATION, `Bearer ${accessToken.token}`);\n        return true;\n    }\n    return false;\n};\n/**\n * Extracts the tenant id from the challenge information\n * The tenant id is contained in the authorization_uri as the first\n * path part.\n */\nfunction extractTenantId(challengeInfo) {\n    const parsedAuthUri = new URL(challengeInfo.authorization_uri);\n    const pathSegments = parsedAuthUri.pathname.split(\"/\");\n    const tenantId = pathSegments[1];\n    return tenantId;\n}\n/**\n * Builds the authentication scopes based on the information that comes in the\n * challenge information. Scopes url is present in the resource_id, if it is empty\n * we keep using the original scopes.\n */\nfunction buildScopes(challengeOptions, challengeInfo) {\n    if (!challengeInfo.resource_uri) {\n        return challengeOptions.scopes;\n    }\n    const challengeScopes = new URL(challengeInfo.resource_uri);\n    challengeScopes.pathname = Constants.DefaultScope;\n    return [challengeScopes.toString()];\n}\n/**\n * We will retrieve the challenge only if the response status code was 401,\n * and if the response contained the header \"WWW-Authenticate\" with a non-empty value.\n */\nfunction getChallenge(response) {\n    const challenge = response.headers.get(\"WWW-Authenticate\");\n    if (response.status === 401 && challenge) {\n        return challenge;\n    }\n    return;\n}\n/**\n * Converts: `Bearer a=\"b\" c=\"d\"`.\n * Into: `[ { a: 'b', c: 'd' }]`.\n *\n * @internal\n */\nfunction parseChallenge(challenge) {\n    const bearerChallenge = challenge.slice(\"Bearer \".length);\n    const challengeParts = `${bearerChallenge.trim()} `.split(\" \").filter((x) => x);\n    const keyValuePairs = challengeParts.map((keyValue) => (([key, value]) => ({ [key]: value }))(keyValue.trim().split(\"=\")));\n    // Key-value pairs to plain object:\n    return keyValuePairs.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});\n}\n/**\n * Extracts the options form a Pipeline Request for later re-use\n */\nfunction requestToOptions(request) {\n    return {\n        abortSignal: request.abortSignal,\n        requestOptions: {\n            timeout: request.timeout,\n        },\n        tracingOptions: request.tracingOptions,\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}