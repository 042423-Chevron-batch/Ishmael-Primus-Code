{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { PerformanceEventStatus } from './PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\nvar PerformanceClient = /** @class */function () {\n  /**\r\n   * Creates an instance of PerformanceClient,\r\n   * an abstract class containing core performance telemetry logic.\r\n   *\r\n   * @constructor\r\n   * @param {string} clientId Client ID of the application\r\n   * @param {string} authority Authority used by the application\r\n   * @param {Logger} logger Logger used by the application\r\n   * @param {string} libraryName Name of the library\r\n   * @param {string} libraryVersion Version of the library\r\n   */\n  function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\n    this.authority = authority;\n    this.libraryName = libraryName;\n    this.libraryVersion = libraryVersion;\n    this.applicationTelemetry = applicationTelemetry;\n    this.clientId = clientId;\n    this.logger = logger;\n    this.callbacks = new Map();\n    this.eventsByCorrelationId = new Map();\n    this.measurementsById = new Map();\n  }\n  /**\r\n   * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {?string} [correlationId]\r\n   * @returns {InProgressPerformanceEvent}\r\n   */\n  PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\n    var _this = this;\n    var _a, _b;\n    // Generate a placeholder correlation if the request does not provide one\n    var eventCorrelationId = correlationId || this.generateId();\n    if (!correlationId) {\n      this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\n    }\n    this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\n    var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\n    performanceMeasurement.startMeasurement();\n    var inProgressEvent = {\n      eventId: this.generateId(),\n      status: PerformanceEventStatus.InProgress,\n      authority: this.authority,\n      libraryName: this.libraryName,\n      libraryVersion: this.libraryVersion,\n      appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\n      appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,\n      clientId: this.clientId,\n      name: measureName,\n      startTimeMs: Date.now(),\n      correlationId: eventCorrelationId\n    };\n    // Store in progress events so they can be discarded if not ended properly\n    this.cacheEventByCorrelationId(inProgressEvent);\n    this.cacheMeasurement(inProgressEvent, performanceMeasurement);\n    // Return the event and functions the caller can use to properly end/flush the measurement\n    return {\n      endMeasurement: function (event) {\n        var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\n        if (completedEvent) {\n          // Cache event so that submeasurements can be added downstream\n          _this.cacheEventByCorrelationId(completedEvent);\n        }\n        return completedEvent;\n      },\n      flushMeasurement: function () {\n        return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\n      },\n      discardMeasurement: function () {\n        return _this.discardMeasurements(inProgressEvent.correlationId);\n      },\n      measurement: performanceMeasurement,\n      event: inProgressEvent\n    };\n  };\n  /**\r\n   * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n   * as consumers should instead use the function returned by startMeasurement.\r\n   *\r\n   * @param {PerformanceEvent} event\r\n   * @returns {(PerformanceEvent | null)}\r\n   */\n  PerformanceClient.prototype.endMeasurement = function (event) {\n    var performanceMeasurement = this.measurementsById.get(event.eventId);\n    if (performanceMeasurement) {\n      // Immediately delete so that the same event isnt ended twice\n      this.measurementsById.delete(event.eventId);\n      performanceMeasurement.endMeasurement();\n      var durationMs = performanceMeasurement.flushMeasurement();\n      // null indicates no measurement was taken (e.g. needed performance APIs not present)\n      if (durationMs !== null) {\n        this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\n        var completedEvent = __assign(__assign({\n          // Allow duration to be overwritten when event ends (e.g. testing), but not status\n          durationMs: Math.round(durationMs)\n        }, event), {\n          status: PerformanceEventStatus.Completed\n        });\n        return completedEvent;\n      } else {\n        this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\n      }\n    } else {\n      this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\n    }\n    return null;\n  };\n  /**\r\n   * Upserts event into event cache.\r\n   * First key is the correlation id, second key is the event id.\r\n   * Allows for events to be grouped by correlation id,\r\n   * and to easily allow for properties on them to be updated.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   */\n  PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\n    var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\n    if (existingEvents) {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\n      existingEvents.set(event.eventId, event);\n    } else {\n      this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\n      this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\n    }\n  };\n  /**\r\n   * Cache measurements by their id.\r\n   *\r\n   * @private\r\n   * @param {PerformanceEvent} event\r\n   * @param {IPerformanceMeasurement} measurement\r\n   */\n  PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\n    this.measurementsById.set(event.eventId, measurement);\n  };\n  /**\r\n   * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n   *\r\n   * @param {PerformanceEvents} measureName\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\n    var _this = this;\n    this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\n    var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\n    if (eventsForCorrelationId) {\n      this.discardMeasurements(correlationId);\n      /*\r\n       * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n       * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n       * IE only supports Map.forEach.\r\n       */\n      var completedEvents_1 = [];\n      eventsForCorrelationId.forEach(function (event) {\n        if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\n          _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\n          var completedEvent = _this.endMeasurement(event);\n          if (completedEvent) {\n            completedEvents_1.push(completedEvent);\n          }\n        }\n        completedEvents_1.push(event);\n      });\n      // Sort events by start time (earliest first)\n      var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) {\n        return eventA.startTimeMs - eventB.startTimeMs;\n      });\n      // Take completed top level event and add completed submeasurements durations as properties\n      var topLevelEvents = sortedCompletedEvents.filter(function (event) {\n        return event.name === measureName && event.status === PerformanceEventStatus.Completed;\n      });\n      if (topLevelEvents.length > 0) {\n        /*\r\n         * Only take the first top-level event if there are multiple events with the same correlation id.\r\n         * This greatly simplifies logic for submeasurements.\r\n         */\n        if (topLevelEvents.length > 1) {\n          this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\n        }\n        var topLevelEvent = topLevelEvents[0];\n        this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId);\n        // Build event object with top level and sub measurements\n        var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\n          if (current.name !== measureName) {\n            _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId);\n            // TODO: Emit additional properties for each subMeasurement\n            var subMeasurementName = current.name + \"DurationMs\";\n            /*\r\n             * Some code paths, such as resolving an authority, can occur multiple times.\r\n             * Only take the first measurement, since the second could be read from the cache,\r\n             * or due to the same correlation id being used for two distinct requests.\r\n             */\n            if (!previous[subMeasurementName]) {\n              previous[subMeasurementName] = current.durationMs;\n            } else {\n              _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\n            }\n            if (current.accessTokenSize) {\n              previous.accessTokenSize = current.accessTokenSize;\n            }\n            if (current.idTokenSize) {\n              previous.idTokenSize = current.idTokenSize;\n            }\n            if (current.refreshTokenSize) {\n              previous.refreshTokenSize = current.refreshTokenSize;\n            }\n          }\n          return previous;\n        }, topLevelEvent);\n        this.emitEvents([eventToEmit], eventToEmit.correlationId);\n      } else {\n        this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\n      }\n    } else {\n      this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\n    }\n  };\n  /**\r\n   * Removes measurements for a given correlation id.\r\n   *\r\n   * @param {string} correlationId\r\n   */\n  PerformanceClient.prototype.discardMeasurements = function (correlationId) {\n    this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\n    this.eventsByCorrelationId.delete(correlationId);\n  };\n  /**\r\n   * Registers a callback function to receive performance events.\r\n   *\r\n   * @param {PerformanceCallbackFunction} callback\r\n   * @returns {string}\r\n   */\n  PerformanceClient.prototype.addPerformanceCallback = function (callback) {\n    var callbackId = this.generateId();\n    this.callbacks.set(callbackId, callback);\n    this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\n    return callbackId;\n  };\n  /**\r\n   * Removes a callback registered with addPerformanceCallback.\r\n   *\r\n   * @param {string} callbackId\r\n   * @returns {boolean}\r\n   */\n  PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\n    var result = this.callbacks.delete(callbackId);\n    if (result) {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\n    } else {\n      this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\n    }\n    return result;\n  };\n  /**\r\n   * Emits events to all registered callbacks.\r\n   *\r\n   * @param {PerformanceEvent[]} events\r\n   * @param {?string} [correlationId]\r\n   */\n  PerformanceClient.prototype.emitEvents = function (events, correlationId) {\n    var _this = this;\n    this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\n    this.callbacks.forEach(function (callback, callbackId) {\n      _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\n      callback.apply(null, [events]);\n    });\n  };\n  return PerformanceClient;\n}();\nexport { PerformanceClient };","map":{"version":3,"names":["__assign","PerformanceEventStatus","PerformanceClient","clientId","authority","logger","libraryName","libraryVersion","applicationTelemetry","callbacks","Map","eventsByCorrelationId","measurementsById","prototype","startMeasurement","measureName","correlationId","_this","_a","_b","eventCorrelationId","generateId","info","trace","performanceMeasurement","startPerformanceMeasuremeant","inProgressEvent","eventId","status","InProgress","appName","appVersion","name","startTimeMs","Date","now","cacheEventByCorrelationId","cacheMeasurement","endMeasurement","event","completedEvent","flushMeasurement","flushMeasurements","discardMeasurement","discardMeasurements","measurement","get","delete","durationMs","Math","round","Completed","existingEvents","set","eventsForCorrelationId","completedEvents_1","forEach","push","sortedCompletedEvents","sort","eventA","eventB","topLevelEvents","filter","length","verbose","topLevelEvent","eventToEmit","reduce","previous","current","subMeasurementName","accessTokenSize","idTokenSize","refreshTokenSize","emitEvents","addPerformanceCallback","callback","callbackId","removePerformanceCallback","result","events","apply"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-common/dist/telemetry/performance/PerformanceClient.js"],"sourcesContent":["/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\nimport { __assign } from '../../_virtual/_tslib.js';\nimport { PerformanceEventStatus } from './PerformanceEvent.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\nvar PerformanceClient = /** @class */ (function () {\r\n    /**\r\n     * Creates an instance of PerformanceClient,\r\n     * an abstract class containing core performance telemetry logic.\r\n     *\r\n     * @constructor\r\n     * @param {string} clientId Client ID of the application\r\n     * @param {string} authority Authority used by the application\r\n     * @param {Logger} logger Logger used by the application\r\n     * @param {string} libraryName Name of the library\r\n     * @param {string} libraryVersion Version of the library\r\n     */\r\n    function PerformanceClient(clientId, authority, logger, libraryName, libraryVersion, applicationTelemetry) {\r\n        this.authority = authority;\r\n        this.libraryName = libraryName;\r\n        this.libraryVersion = libraryVersion;\r\n        this.applicationTelemetry = applicationTelemetry;\r\n        this.clientId = clientId;\r\n        this.logger = logger;\r\n        this.callbacks = new Map();\r\n        this.eventsByCorrelationId = new Map();\r\n        this.measurementsById = new Map();\r\n    }\r\n    /**\r\n     * Starts measuring performance for a given operation. Returns a function that should be used to end the measurement.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {?string} [correlationId]\r\n     * @returns {InProgressPerformanceEvent}\r\n     */\r\n    PerformanceClient.prototype.startMeasurement = function (measureName, correlationId) {\r\n        var _this = this;\r\n        var _a, _b;\r\n        // Generate a placeholder correlation if the request does not provide one\r\n        var eventCorrelationId = correlationId || this.generateId();\r\n        if (!correlationId) {\r\n            this.logger.info(\"PerformanceClient: No correlation id provided for \" + measureName + \", generating\", eventCorrelationId);\r\n        }\r\n        this.logger.trace(\"PerformanceClient: Performance measurement started for \" + measureName, eventCorrelationId);\r\n        var performanceMeasurement = this.startPerformanceMeasuremeant(measureName, eventCorrelationId);\r\n        performanceMeasurement.startMeasurement();\r\n        var inProgressEvent = {\r\n            eventId: this.generateId(),\r\n            status: PerformanceEventStatus.InProgress,\r\n            authority: this.authority,\r\n            libraryName: this.libraryName,\r\n            libraryVersion: this.libraryVersion,\r\n            appName: (_a = this.applicationTelemetry) === null || _a === void 0 ? void 0 : _a.appName,\r\n            appVersion: (_b = this.applicationTelemetry) === null || _b === void 0 ? void 0 : _b.appVersion,\r\n            clientId: this.clientId,\r\n            name: measureName,\r\n            startTimeMs: Date.now(),\r\n            correlationId: eventCorrelationId,\r\n        };\r\n        // Store in progress events so they can be discarded if not ended properly\r\n        this.cacheEventByCorrelationId(inProgressEvent);\r\n        this.cacheMeasurement(inProgressEvent, performanceMeasurement);\r\n        // Return the event and functions the caller can use to properly end/flush the measurement\r\n        return {\r\n            endMeasurement: function (event) {\r\n                var completedEvent = _this.endMeasurement(__assign(__assign({}, inProgressEvent), event));\r\n                if (completedEvent) {\r\n                    // Cache event so that submeasurements can be added downstream\r\n                    _this.cacheEventByCorrelationId(completedEvent);\r\n                }\r\n                return completedEvent;\r\n            },\r\n            flushMeasurement: function () {\r\n                return _this.flushMeasurements(inProgressEvent.name, inProgressEvent.correlationId);\r\n            },\r\n            discardMeasurement: function () {\r\n                return _this.discardMeasurements(inProgressEvent.correlationId);\r\n            },\r\n            measurement: performanceMeasurement,\r\n            event: inProgressEvent\r\n        };\r\n    };\r\n    /**\r\n     * Stops measuring the performance for an operation. Should only be called directly by PerformanceClient classes,\r\n     * as consumers should instead use the function returned by startMeasurement.\r\n     *\r\n     * @param {PerformanceEvent} event\r\n     * @returns {(PerformanceEvent | null)}\r\n     */\r\n    PerformanceClient.prototype.endMeasurement = function (event) {\r\n        var performanceMeasurement = this.measurementsById.get(event.eventId);\r\n        if (performanceMeasurement) {\r\n            // Immediately delete so that the same event isnt ended twice\r\n            this.measurementsById.delete(event.eventId);\r\n            performanceMeasurement.endMeasurement();\r\n            var durationMs = performanceMeasurement.flushMeasurement();\r\n            // null indicates no measurement was taken (e.g. needed performance APIs not present)\r\n            if (durationMs !== null) {\r\n                this.logger.trace(\"PerformanceClient: Performance measurement ended for \" + event.name + \": \" + durationMs + \" ms\", event.correlationId);\r\n                var completedEvent = __assign(__assign({ \r\n                    // Allow duration to be overwritten when event ends (e.g. testing), but not status\r\n                    durationMs: Math.round(durationMs) }, event), { status: PerformanceEventStatus.Completed });\r\n                return completedEvent;\r\n            }\r\n            else {\r\n                this.logger.trace(\"PerformanceClient: Performance measurement not taken\", event.correlationId);\r\n            }\r\n        }\r\n        else {\r\n            this.logger.trace(\"PerformanceClient: Measurement not found for \" + event.eventId, event.correlationId);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Upserts event into event cache.\r\n     * First key is the correlation id, second key is the event id.\r\n     * Allows for events to be grouped by correlation id,\r\n     * and to easily allow for properties on them to be updated.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     */\r\n    PerformanceClient.prototype.cacheEventByCorrelationId = function (event) {\r\n        var existingEvents = this.eventsByCorrelationId.get(event.correlationId);\r\n        if (existingEvents) {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" added/updated\", event.correlationId);\r\n            existingEvents.set(event.eventId, event);\r\n        }\r\n        else {\r\n            this.logger.trace(\"PerformanceClient: Performance measurement for \" + event.name + \" started\", event.correlationId);\r\n            this.eventsByCorrelationId.set(event.correlationId, new Map().set(event.eventId, event));\r\n        }\r\n    };\r\n    /**\r\n     * Cache measurements by their id.\r\n     *\r\n     * @private\r\n     * @param {PerformanceEvent} event\r\n     * @param {IPerformanceMeasurement} measurement\r\n     */\r\n    PerformanceClient.prototype.cacheMeasurement = function (event, measurement) {\r\n        this.measurementsById.set(event.eventId, measurement);\r\n    };\r\n    /**\r\n     * Gathers and emits performance events for measurements taked for the given top-level API and correlation ID.\r\n     *\r\n     * @param {PerformanceEvents} measureName\r\n     * @param {string} correlationId\r\n     */\r\n    PerformanceClient.prototype.flushMeasurements = function (measureName, correlationId) {\r\n        var _this = this;\r\n        this.logger.trace(\"PerformanceClient: Performance measurements flushed for \" + measureName, correlationId);\r\n        var eventsForCorrelationId = this.eventsByCorrelationId.get(correlationId);\r\n        if (eventsForCorrelationId) {\r\n            this.discardMeasurements(correlationId);\r\n            /*\r\n             * Manually end incomplete submeasurements to ensure there arent orphaned/never ending events.\r\n             * Incomplete submeasurements are likely an instrumentation bug that should be fixed.\r\n             * IE only supports Map.forEach.\r\n             */\r\n            var completedEvents_1 = [];\r\n            eventsForCorrelationId.forEach(function (event) {\r\n                if (event.name !== measureName && event.status !== PerformanceEventStatus.Completed) {\r\n                    _this.logger.trace(\"PerformanceClient: Incomplete submeasurement \" + event.name + \" found for \" + measureName, correlationId);\r\n                    var completedEvent = _this.endMeasurement(event);\r\n                    if (completedEvent) {\r\n                        completedEvents_1.push(completedEvent);\r\n                    }\r\n                }\r\n                completedEvents_1.push(event);\r\n            });\r\n            // Sort events by start time (earliest first)\r\n            var sortedCompletedEvents = completedEvents_1.sort(function (eventA, eventB) { return eventA.startTimeMs - eventB.startTimeMs; });\r\n            // Take completed top level event and add completed submeasurements durations as properties\r\n            var topLevelEvents = sortedCompletedEvents.filter(function (event) { return event.name === measureName && event.status === PerformanceEventStatus.Completed; });\r\n            if (topLevelEvents.length > 0) {\r\n                /*\r\n                 * Only take the first top-level event if there are multiple events with the same correlation id.\r\n                 * This greatly simplifies logic for submeasurements.\r\n                 */\r\n                if (topLevelEvents.length > 1) {\r\n                    this.logger.verbose(\"PerformanceClient: Multiple distinct top-level performance events found, using the first\", correlationId);\r\n                }\r\n                var topLevelEvent = topLevelEvents[0];\r\n                this.logger.verbose(\"PerformanceClient: Measurement found for \" + measureName, correlationId);\r\n                // Build event object with top level and sub measurements\r\n                var eventToEmit = sortedCompletedEvents.reduce(function (previous, current) {\r\n                    if (current.name !== measureName) {\r\n                        _this.logger.trace(\"PerformanceClient: Complete submeasurement found for \" + current.name, correlationId);\r\n                        // TODO: Emit additional properties for each subMeasurement\r\n                        var subMeasurementName = current.name + \"DurationMs\";\r\n                        /*\r\n                         * Some code paths, such as resolving an authority, can occur multiple times.\r\n                         * Only take the first measurement, since the second could be read from the cache,\r\n                         * or due to the same correlation id being used for two distinct requests.\r\n                         */\r\n                        if (!previous[subMeasurementName]) {\r\n                            previous[subMeasurementName] = current.durationMs;\r\n                        }\r\n                        else {\r\n                            _this.logger.verbose(\"PerformanceClient: Submeasurement for \" + measureName + \" already exists for \" + current.name + \", ignoring\", correlationId);\r\n                        }\r\n                        if (current.accessTokenSize) {\r\n                            previous.accessTokenSize = current.accessTokenSize;\r\n                        }\r\n                        if (current.idTokenSize) {\r\n                            previous.idTokenSize = current.idTokenSize;\r\n                        }\r\n                        if (current.refreshTokenSize) {\r\n                            previous.refreshTokenSize = current.refreshTokenSize;\r\n                        }\r\n                    }\r\n                    return previous;\r\n                }, topLevelEvent);\r\n                this.emitEvents([eventToEmit], eventToEmit.correlationId);\r\n            }\r\n            else {\r\n                this.logger.verbose(\"PerformanceClient: No completed top-level measurements found for \" + measureName, correlationId);\r\n            }\r\n        }\r\n        else {\r\n            this.logger.verbose(\"PerformanceClient: No measurements found\", correlationId);\r\n        }\r\n    };\r\n    /**\r\n     * Removes measurements for a given correlation id.\r\n     *\r\n     * @param {string} correlationId\r\n     */\r\n    PerformanceClient.prototype.discardMeasurements = function (correlationId) {\r\n        this.logger.trace(\"PerformanceClient: Performance measurements discarded\", correlationId);\r\n        this.eventsByCorrelationId.delete(correlationId);\r\n    };\r\n    /**\r\n     * Registers a callback function to receive performance events.\r\n     *\r\n     * @param {PerformanceCallbackFunction} callback\r\n     * @returns {string}\r\n     */\r\n    PerformanceClient.prototype.addPerformanceCallback = function (callback) {\r\n        var callbackId = this.generateId();\r\n        this.callbacks.set(callbackId, callback);\r\n        this.logger.verbose(\"PerformanceClient: Performance callback registered with id: \" + callbackId);\r\n        return callbackId;\r\n    };\r\n    /**\r\n     * Removes a callback registered with addPerformanceCallback.\r\n     *\r\n     * @param {string} callbackId\r\n     * @returns {boolean}\r\n     */\r\n    PerformanceClient.prototype.removePerformanceCallback = function (callbackId) {\r\n        var result = this.callbacks.delete(callbackId);\r\n        if (result) {\r\n            this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" removed.\");\r\n        }\r\n        else {\r\n            this.logger.verbose(\"PerformanceClient: Performance callback \" + callbackId + \" not removed.\");\r\n        }\r\n        return result;\r\n    };\r\n    /**\r\n     * Emits events to all registered callbacks.\r\n     *\r\n     * @param {PerformanceEvent[]} events\r\n     * @param {?string} [correlationId]\r\n     */\r\n    PerformanceClient.prototype.emitEvents = function (events, correlationId) {\r\n        var _this = this;\r\n        this.logger.verbose(\"PerformanceClient: Emitting performance events\", correlationId);\r\n        this.callbacks.forEach(function (callback, callbackId) {\r\n            _this.logger.trace(\"PerformanceClient: Emitting event to callback \" + callbackId, correlationId);\r\n            callback.apply(null, [events]);\r\n        });\r\n    };\r\n    return PerformanceClient;\r\n}());\n\nexport { PerformanceClient };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}