{"ast":null,"code":"/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\n\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AuthenticationScheme, CredentialType, GrantType, AADServerParamKeys, CacheOutcome, Constants } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * On-Behalf-Of client\r\n */\nvar OnBehalfOfClient = /** @class */function (_super) {\n  __extends(OnBehalfOfClient, _super);\n  function OnBehalfOfClient(configuration) {\n    return _super.call(this, configuration) || this;\n  }\n  /**\r\n   * Public API to acquire tokens with on behalf of flow\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.acquireToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this.scopeSet = new ScopeSet(request.scopes || []);\n            // generate the user_assertion_hash for OBOAssertion\n            _a = this;\n            return [4 /*yield*/, this.cryptoUtils.hashString(request.oboAssertion)];\n          case 1:\n            // generate the user_assertion_hash for OBOAssertion\n            _a.userAssertionHash = _b.sent();\n            if (!request.skipCache) return [3 /*break*/, 3];\n            return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n          case 3:\n            _b.trys.push([3, 5,, 7]);\n            return [4 /*yield*/, this.getCachedAuthenticationResult(request)];\n          case 4:\n            return [2 /*return*/, _b.sent()];\n          case 5:\n            _b.sent();\n            return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\n          case 6:\n            // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\n            return [2 /*return*/, _b.sent()];\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * look up cache for tokens\r\n   * Find idtoken in the cache\r\n   * Find accessToken based on user assertion and account info in the cache\r\n   * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\r\n   * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.getCachedAuthenticationResult = function (request) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;\n      return __generator(this, function (_c) {\n        switch (_c.label) {\n          case 0:\n            cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);\n            if (!cachedAccessToken) {\n              // Must refresh due to non-existent access_token.\n              (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\n              this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            } else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\n              // Access token expired, will need to renewed\n              (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\n              this.logger.info(\"OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\n              throw ClientAuthError.createRefreshRequiredError();\n            }\n            cachedIdToken = this.readIdTokenFromCacheForOBO(request, cachedAccessToken.homeAccountId);\n            cachedAccount = null;\n            if (cachedIdToken) {\n              idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);\n              localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;\n              accountInfo = {\n                homeAccountId: cachedIdToken.homeAccountId,\n                environment: cachedIdToken.environment,\n                tenantId: cachedIdToken.realm,\n                username: Constants.EMPTY_STRING,\n                localAccountId: localAccountId || Constants.EMPTY_STRING\n              };\n              cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\n            }\n            // increment telemetry cache hit counter\n            if (this.config.serverTelemetryManager) {\n              this.config.serverTelemetryManager.incrementCacheHits();\n            }\n            return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {\n              account: cachedAccount,\n              accessToken: cachedAccessToken,\n              idToken: cachedIdToken,\n              refreshToken: null,\n              appMetadata: null\n            }, true, request, idTokenObject)];\n          case 1:\n            return [2 /*return*/, _c.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\r\n   * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.readIdTokenFromCacheForOBO = function (request, atHomeAccountId) {\n    var idTokenFilter = {\n      homeAccountId: atHomeAccountId,\n      environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: this.config.authOptions.clientId,\n      realm: this.authority.tenant\n    };\n    var credentialCache = this.cacheManager.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    // When acquiring a token on behalf of an application, there might not be an id token in the cache\n    if (idTokens.length < 1) {\n      return null;\n    }\n    return idTokens[0];\n  };\n  /**\r\n   * Fetches the cached access token based on incoming assertion\r\n   * @param clientId\r\n   * @param request\r\n   * @param userAssertionHash\r\n   */\n  OnBehalfOfClient.prototype.readAccessTokenFromCacheForOBO = function (clientId, request) {\n    var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\n    /*\r\n     * Distinguish between Bearer and PoP/SSH token cache types\r\n     * Cast to lowercase to handle \"bearer\" from ADFS\r\n     */\n    var credentialType = authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase() ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      credentialType: credentialType,\n      clientId: clientId,\n      target: this.scopeSet.printScopesLowerCase(),\n      tokenType: authScheme,\n      keyId: request.sshKid,\n      requestedClaimsHash: request.requestedClaimsHash,\n      userAssertionHash: this.userAssertionHash\n    };\n    var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError.createMultipleMatchingTokensInCacheError();\n    }\n    return accessTokens[0];\n  };\n  /**\r\n   * Make a network call to the server requesting credentials\r\n   * @param request\r\n   * @param authority\r\n   */\n  OnBehalfOfClient.prototype.executeTokenRequest = function (request, authority, userAssertionHash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            requestBody = this.createTokenRequestBody(request);\n            headers = this.createTokenRequestHeaders();\n            thumbprint = {\n              clientId: this.config.authOptions.clientId,\n              authority: request.authority,\n              scopes: request.scopes,\n              claims: request.claims,\n              authenticationScheme: request.authenticationScheme,\n              resourceRequestMethod: request.resourceRequestMethod,\n              resourceRequestUri: request.resourceRequestUri,\n              shrClaims: request.shrClaims,\n              sshKid: request.sshKid\n            };\n            reqTimestamp = TimeUtils.nowSeconds();\n            return [4 /*yield*/, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];\n          case 1:\n            response = _a.sent();\n            responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\n            responseHandler.validateTokenResponse(response.body);\n            return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash)];\n          case 2:\n            tokenResponse = _a.sent();\n            return [2 /*return*/, tokenResponse];\n        }\n      });\n    });\n  };\n  /**\r\n   * generate a server request in accepable format\r\n   * @param request\r\n   */\n  OnBehalfOfClient.prototype.createTokenRequestBody = function (request) {\n    var parameterBuilder = new RequestParameterBuilder();\n    parameterBuilder.addClientId(this.config.authOptions.clientId);\n    parameterBuilder.addScopes(request.scopes);\n    parameterBuilder.addGrantType(GrantType.JWT_BEARER);\n    parameterBuilder.addClientInfo();\n    parameterBuilder.addLibraryInfo(this.config.libraryInfo);\n    parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\n    parameterBuilder.addThrottling();\n    if (this.serverTelemetryManager) {\n      parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\n    }\n    var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\n    parameterBuilder.addCorrelationId(correlationId);\n    parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);\n    parameterBuilder.addOboAssertion(request.oboAssertion);\n    if (this.config.clientCredentials.clientSecret) {\n      parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\n    }\n    if (this.config.clientCredentials.clientAssertion) {\n      var clientAssertion = this.config.clientCredentials.clientAssertion;\n      parameterBuilder.addClientAssertion(clientAssertion.assertion);\n      parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\n    }\n    return parameterBuilder.createQueryString();\n  };\n  return OnBehalfOfClient;\n}(BaseClient);\nexport { OnBehalfOfClient };","map":{"version":3,"names":["__extends","__awaiter","__generator","BaseClient","RequestParameterBuilder","ScopeSet","AuthenticationScheme","CredentialType","GrantType","AADServerParamKeys","CacheOutcome","Constants","ResponseHandler","TimeUtils","AuthToken","ClientAuthError","OnBehalfOfClient","_super","configuration","call","prototype","acquireToken","request","_a","_b","label","scopeSet","scopes","cryptoUtils","hashString","oboAssertion","userAssertionHash","sent","skipCache","executeTokenRequest","authority","trys","push","getCachedAuthenticationResult","cachedAccessToken","cachedIdToken","idTokenObject","cachedAccount","localAccountId","accountInfo","_c","readAccessTokenFromCacheForOBO","config","authOptions","clientId","serverTelemetryManager","setCacheOutcome","NO_CACHED_ACCESS_TOKEN","logger","info","createRefreshRequiredError","isTokenExpired","expiresOn","systemOptions","tokenRenewalOffsetSeconds","CACHED_ACCESS_TOKEN_EXPIRED","readIdTokenFromCacheForOBO","homeAccountId","secret","cryptoInterface","claims","oid","sub","environment","tenantId","realm","username","EMPTY_STRING","cacheManager","readAccountFromCache","incrementCacheHits","generateAuthenticationResult","account","accessToken","idToken","refreshToken","appMetadata","atHomeAccountId","idTokenFilter","canonicalAuthorityUrlComponents","HostNameAndPort","credentialType","ID_TOKEN","tenant","credentialCache","getCredentialsFilteredBy","idTokens","Object","keys","map","key","length","authScheme","authenticationScheme","BEARER","toLowerCase","ACCESS_TOKEN_WITH_AUTH_SCHEME","ACCESS_TOKEN","accessTokenFilter","target","printScopesLowerCase","tokenType","keyId","sshKid","requestedClaimsHash","accessTokens","numAccessTokens","createMultipleMatchingTokensInCacheError","requestBody","headers","thumbprint","reqTimestamp","response","responseHandler","tokenResponse","createTokenRequestBody","createTokenRequestHeaders","resourceRequestMethod","resourceRequestUri","shrClaims","nowSeconds","executePostToTokenEndpoint","tokenEndpoint","serializableCache","persistencePlugin","validateTokenResponse","body","handleServerTokenResponse","undefined","parameterBuilder","addClientId","addScopes","addGrantType","JWT_BEARER","addClientInfo","addLibraryInfo","libraryInfo","addApplicationTelemetry","telemetry","application","addThrottling","addServerTelemetry","correlationId","createNewGuid","addCorrelationId","addRequestTokenUse","ON_BEHALF_OF","addOboAssertion","clientCredentials","clientSecret","addClientSecret","clientAssertion","addClientAssertion","assertion","addClientAssertionType","assertionType","createQueryString"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-common/dist/client/OnBehalfOfClient.js"],"sourcesContent":["/*! @azure/msal-common v7.6.0 2022-10-10 */\n'use strict';\nimport { __extends, __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BaseClient } from './BaseClient.js';\nimport { RequestParameterBuilder } from '../request/RequestParameterBuilder.js';\nimport { ScopeSet } from '../request/ScopeSet.js';\nimport { AuthenticationScheme, CredentialType, GrantType, AADServerParamKeys, CacheOutcome, Constants } from '../utils/Constants.js';\nimport { ResponseHandler } from '../response/ResponseHandler.js';\nimport { TimeUtils } from '../utils/TimeUtils.js';\nimport { AuthToken } from '../account/AuthToken.js';\nimport { ClientAuthError } from '../error/ClientAuthError.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * On-Behalf-Of client\r\n */\r\nvar OnBehalfOfClient = /** @class */ (function (_super) {\r\n    __extends(OnBehalfOfClient, _super);\r\n    function OnBehalfOfClient(configuration) {\r\n        return _super.call(this, configuration) || this;\r\n    }\r\n    /**\r\n     * Public API to acquire tokens with on behalf of flow\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.acquireToken = function (request) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        this.scopeSet = new ScopeSet(request.scopes || []);\r\n                        // generate the user_assertion_hash for OBOAssertion\r\n                        _a = this;\r\n                        return [4 /*yield*/, this.cryptoUtils.hashString(request.oboAssertion)];\r\n                    case 1:\r\n                        // generate the user_assertion_hash for OBOAssertion\r\n                        _a.userAssertionHash = _b.sent();\r\n                        if (!request.skipCache) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\r\n                    case 2: return [2 /*return*/, _b.sent()];\r\n                    case 3:\r\n                        _b.trys.push([3, 5, , 7]);\r\n                        return [4 /*yield*/, this.getCachedAuthenticationResult(request)];\r\n                    case 4: return [2 /*return*/, _b.sent()];\r\n                    case 5:\r\n                        _b.sent();\r\n                        return [4 /*yield*/, this.executeTokenRequest(request, this.authority, this.userAssertionHash)];\r\n                    case 6: \r\n                    // Any failure falls back to interactive request, once we implement distributed cache, we plan to handle `createRefreshRequiredError` to refresh using the RT\r\n                    return [2 /*return*/, _b.sent()];\r\n                    case 7: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * look up cache for tokens\r\n     * Find idtoken in the cache\r\n     * Find accessToken based on user assertion and account info in the cache\r\n     * Please note we are not yet supported OBO tokens refreshed with long lived RT. User will have to send a new assertion if the current access token expires\r\n     * This is to prevent security issues when the assertion changes over time, however, longlived RT helps retaining the session\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.getCachedAuthenticationResult = function (request) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var cachedAccessToken, cachedIdToken, idTokenObject, cachedAccount, localAccountId, accountInfo;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        cachedAccessToken = this.readAccessTokenFromCacheForOBO(this.config.authOptions.clientId, request);\r\n                        if (!cachedAccessToken) {\r\n                            // Must refresh due to non-existent access_token.\r\n                            (_a = this.serverTelemetryManager) === null || _a === void 0 ? void 0 : _a.setCacheOutcome(CacheOutcome.NO_CACHED_ACCESS_TOKEN);\r\n                            this.logger.info(\"SilentFlowClient:acquireCachedToken - No access token found in cache for the given properties.\");\r\n                            throw ClientAuthError.createRefreshRequiredError();\r\n                        }\r\n                        else if (TimeUtils.isTokenExpired(cachedAccessToken.expiresOn, this.config.systemOptions.tokenRenewalOffsetSeconds)) {\r\n                            // Access token expired, will need to renewed\r\n                            (_b = this.serverTelemetryManager) === null || _b === void 0 ? void 0 : _b.setCacheOutcome(CacheOutcome.CACHED_ACCESS_TOKEN_EXPIRED);\r\n                            this.logger.info(\"OnbehalfofFlow:getCachedAuthenticationResult - Cached access token is expired or will expire within \" + this.config.systemOptions.tokenRenewalOffsetSeconds + \" seconds.\");\r\n                            throw ClientAuthError.createRefreshRequiredError();\r\n                        }\r\n                        cachedIdToken = this.readIdTokenFromCacheForOBO(request, cachedAccessToken.homeAccountId);\r\n                        cachedAccount = null;\r\n                        if (cachedIdToken) {\r\n                            idTokenObject = new AuthToken(cachedIdToken.secret, this.config.cryptoInterface);\r\n                            localAccountId = idTokenObject.claims.oid ? idTokenObject.claims.oid : idTokenObject.claims.sub;\r\n                            accountInfo = {\r\n                                homeAccountId: cachedIdToken.homeAccountId,\r\n                                environment: cachedIdToken.environment,\r\n                                tenantId: cachedIdToken.realm,\r\n                                username: Constants.EMPTY_STRING,\r\n                                localAccountId: localAccountId || Constants.EMPTY_STRING\r\n                            };\r\n                            cachedAccount = this.cacheManager.readAccountFromCache(accountInfo);\r\n                        }\r\n                        // increment telemetry cache hit counter\r\n                        if (this.config.serverTelemetryManager) {\r\n                            this.config.serverTelemetryManager.incrementCacheHits();\r\n                        }\r\n                        return [4 /*yield*/, ResponseHandler.generateAuthenticationResult(this.cryptoUtils, this.authority, {\r\n                                account: cachedAccount,\r\n                                accessToken: cachedAccessToken,\r\n                                idToken: cachedIdToken,\r\n                                refreshToken: null,\r\n                                appMetadata: null\r\n                            }, true, request, idTokenObject)];\r\n                    case 1: return [2 /*return*/, _c.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * read idtoken from cache, this is a specific implementation for OBO as the requirements differ from a generic lookup in the cacheManager\r\n     * Certain use cases of OBO flow do not expect an idToken in the cache/or from the service\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.readIdTokenFromCacheForOBO = function (request, atHomeAccountId) {\r\n        var idTokenFilter = {\r\n            homeAccountId: atHomeAccountId,\r\n            environment: this.authority.canonicalAuthorityUrlComponents.HostNameAndPort,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: this.config.authOptions.clientId,\r\n            realm: this.authority.tenant\r\n        };\r\n        var credentialCache = this.cacheManager.getCredentialsFilteredBy(idTokenFilter);\r\n        var idTokens = Object.keys(credentialCache.idTokens).map(function (key) { return credentialCache.idTokens[key]; });\r\n        // When acquiring a token on behalf of an application, there might not be an id token in the cache\r\n        if (idTokens.length < 1) {\r\n            return null;\r\n        }\r\n        return idTokens[0];\r\n    };\r\n    /**\r\n     * Fetches the cached access token based on incoming assertion\r\n     * @param clientId\r\n     * @param request\r\n     * @param userAssertionHash\r\n     */\r\n    OnBehalfOfClient.prototype.readAccessTokenFromCacheForOBO = function (clientId, request) {\r\n        var authScheme = request.authenticationScheme || AuthenticationScheme.BEARER;\r\n        /*\r\n         * Distinguish between Bearer and PoP/SSH token cache types\r\n         * Cast to lowercase to handle \"bearer\" from ADFS\r\n         */\r\n        var credentialType = (authScheme && authScheme.toLowerCase() !== AuthenticationScheme.BEARER.toLowerCase()) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n        var accessTokenFilter = {\r\n            credentialType: credentialType,\r\n            clientId: clientId,\r\n            target: this.scopeSet.printScopesLowerCase(),\r\n            tokenType: authScheme,\r\n            keyId: request.sshKid,\r\n            requestedClaimsHash: request.requestedClaimsHash,\r\n            userAssertionHash: this.userAssertionHash\r\n        };\r\n        var credentialCache = this.cacheManager.getCredentialsFilteredBy(accessTokenFilter);\r\n        var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) { return credentialCache.accessTokens[key]; });\r\n        var numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        }\r\n        else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n        return accessTokens[0];\r\n    };\r\n    /**\r\n     * Make a network call to the server requesting credentials\r\n     * @param request\r\n     * @param authority\r\n     */\r\n    OnBehalfOfClient.prototype.executeTokenRequest = function (request, authority, userAssertionHash) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var requestBody, headers, thumbprint, reqTimestamp, response, responseHandler, tokenResponse;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        requestBody = this.createTokenRequestBody(request);\r\n                        headers = this.createTokenRequestHeaders();\r\n                        thumbprint = {\r\n                            clientId: this.config.authOptions.clientId,\r\n                            authority: request.authority,\r\n                            scopes: request.scopes,\r\n                            claims: request.claims,\r\n                            authenticationScheme: request.authenticationScheme,\r\n                            resourceRequestMethod: request.resourceRequestMethod,\r\n                            resourceRequestUri: request.resourceRequestUri,\r\n                            shrClaims: request.shrClaims,\r\n                            sshKid: request.sshKid\r\n                        };\r\n                        reqTimestamp = TimeUtils.nowSeconds();\r\n                        return [4 /*yield*/, this.executePostToTokenEndpoint(authority.tokenEndpoint, requestBody, headers, thumbprint)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        responseHandler = new ResponseHandler(this.config.authOptions.clientId, this.cacheManager, this.cryptoUtils, this.logger, this.config.serializableCache, this.config.persistencePlugin);\r\n                        responseHandler.validateTokenResponse(response.body);\r\n                        return [4 /*yield*/, responseHandler.handleServerTokenResponse(response.body, this.authority, reqTimestamp, request, undefined, userAssertionHash)];\r\n                    case 2:\r\n                        tokenResponse = _a.sent();\r\n                        return [2 /*return*/, tokenResponse];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * generate a server request in accepable format\r\n     * @param request\r\n     */\r\n    OnBehalfOfClient.prototype.createTokenRequestBody = function (request) {\r\n        var parameterBuilder = new RequestParameterBuilder();\r\n        parameterBuilder.addClientId(this.config.authOptions.clientId);\r\n        parameterBuilder.addScopes(request.scopes);\r\n        parameterBuilder.addGrantType(GrantType.JWT_BEARER);\r\n        parameterBuilder.addClientInfo();\r\n        parameterBuilder.addLibraryInfo(this.config.libraryInfo);\r\n        parameterBuilder.addApplicationTelemetry(this.config.telemetry.application);\r\n        parameterBuilder.addThrottling();\r\n        if (this.serverTelemetryManager) {\r\n            parameterBuilder.addServerTelemetry(this.serverTelemetryManager);\r\n        }\r\n        var correlationId = request.correlationId || this.config.cryptoInterface.createNewGuid();\r\n        parameterBuilder.addCorrelationId(correlationId);\r\n        parameterBuilder.addRequestTokenUse(AADServerParamKeys.ON_BEHALF_OF);\r\n        parameterBuilder.addOboAssertion(request.oboAssertion);\r\n        if (this.config.clientCredentials.clientSecret) {\r\n            parameterBuilder.addClientSecret(this.config.clientCredentials.clientSecret);\r\n        }\r\n        if (this.config.clientCredentials.clientAssertion) {\r\n            var clientAssertion = this.config.clientCredentials.clientAssertion;\r\n            parameterBuilder.addClientAssertion(clientAssertion.assertion);\r\n            parameterBuilder.addClientAssertionType(clientAssertion.assertionType);\r\n        }\r\n        return parameterBuilder.createQueryString();\r\n    };\r\n    return OnBehalfOfClient;\r\n}(BaseClient));\n\nexport { OnBehalfOfClient };\n"],"mappings":"AAAA;AACA,YAAY;;AACZ,SAASA,SAAS,EAAEC,SAAS,EAAEC,WAAW,QAAQ,uBAAuB;AACzE,SAASC,UAAU,QAAQ,iBAAiB;AAC5C,SAASC,uBAAuB,QAAQ,uCAAuC;AAC/E,SAASC,QAAQ,QAAQ,wBAAwB;AACjD,SAASC,oBAAoB,EAAEC,cAAc,EAAEC,SAAS,EAAEC,kBAAkB,EAAEC,YAAY,EAAEC,SAAS,QAAQ,uBAAuB;AACpI,SAASC,eAAe,QAAQ,gCAAgC;AAChE,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,SAAS,QAAQ,yBAAyB;AACnD,SAASC,eAAe,QAAQ,6BAA6B;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIC,gBAAgB,GAAG,aAAe,UAAUC,MAAM,EAAE;EACpDjB,SAAS,CAACgB,gBAAgB,EAAEC,MAAM,CAAC;EACnC,SAASD,gBAAgBA,CAACE,aAAa,EAAE;IACrC,OAAOD,MAAM,CAACE,IAAI,CAAC,IAAI,EAAED,aAAa,CAAC,IAAI,IAAI;EACnD;EACA;AACJ;AACA;AACA;EACIF,gBAAgB,CAACI,SAAS,CAACC,YAAY,GAAG,UAAUC,OAAO,EAAE;IACzD,OAAOrB,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;MAC/C,IAAIsB,EAAE;MACN,OAAOrB,WAAW,CAAC,IAAI,EAAE,UAAUsB,EAAE,EAAE;QACnC,QAAQA,EAAE,CAACC,KAAK;UACZ,KAAK,CAAC;YACF,IAAI,CAACC,QAAQ,GAAG,IAAIrB,QAAQ,CAACiB,OAAO,CAACK,MAAM,IAAI,EAAE,CAAC;YAClD;YACAJ,EAAE,GAAG,IAAI;YACT,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACK,WAAW,CAACC,UAAU,CAACP,OAAO,CAACQ,YAAY,CAAC,CAAC;UAC3E,KAAK,CAAC;YACF;YACAP,EAAE,CAACQ,iBAAiB,GAAGP,EAAE,CAACQ,IAAI,EAAE;YAChC,IAAI,CAACV,OAAO,CAACW,SAAS,EAAE,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC;YAC/C,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACC,mBAAmB,CAACZ,OAAO,EAAE,IAAI,CAACa,SAAS,EAAE,IAAI,CAACJ,iBAAiB,CAAC,CAAC;UACnG,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,YAAYP,EAAE,CAACQ,IAAI,EAAE,CAAC;UACxC,KAAK,CAAC;YACFR,EAAE,CAACY,IAAI,CAACC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,GAAI,CAAC,CAAC,CAAC;YACzB,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACC,6BAA6B,CAAChB,OAAO,CAAC,CAAC;UACrE,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,YAAYE,EAAE,CAACQ,IAAI,EAAE,CAAC;UACxC,KAAK,CAAC;YACFR,EAAE,CAACQ,IAAI,EAAE;YACT,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACE,mBAAmB,CAACZ,OAAO,EAAE,IAAI,CAACa,SAAS,EAAE,IAAI,CAACJ,iBAAiB,CAAC,CAAC;UACnG,KAAK,CAAC;YACN;YACA,OAAO,CAAC,CAAC,CAAC,YAAYP,EAAE,CAACQ,IAAI,EAAE,CAAC;UAChC,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,WAAW;QAAC;MAEtC,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIhB,gBAAgB,CAACI,SAAS,CAACkB,6BAA6B,GAAG,UAAUhB,OAAO,EAAE;IAC1E,IAAIC,EAAE,EAAEC,EAAE;IACV,OAAOvB,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;MAC/C,IAAIsC,iBAAiB,EAAEC,aAAa,EAAEC,aAAa,EAAEC,aAAa,EAAEC,cAAc,EAAEC,WAAW;MAC/F,OAAO1C,WAAW,CAAC,IAAI,EAAE,UAAU2C,EAAE,EAAE;QACnC,QAAQA,EAAE,CAACpB,KAAK;UACZ,KAAK,CAAC;YACFc,iBAAiB,GAAG,IAAI,CAACO,8BAA8B,CAAC,IAAI,CAACC,MAAM,CAACC,WAAW,CAACC,QAAQ,EAAE3B,OAAO,CAAC;YAClG,IAAI,CAACiB,iBAAiB,EAAE;cACpB;cACA,CAAChB,EAAE,GAAG,IAAI,CAAC2B,sBAAsB,MAAM,IAAI,IAAI3B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC4B,eAAe,CAACzC,YAAY,CAAC0C,sBAAsB,CAAC;cAC/H,IAAI,CAACC,MAAM,CAACC,IAAI,CAAC,gGAAgG,CAAC;cAClH,MAAMvC,eAAe,CAACwC,0BAA0B,EAAE;YACtD,CAAC,MACI,IAAI1C,SAAS,CAAC2C,cAAc,CAACjB,iBAAiB,CAACkB,SAAS,EAAE,IAAI,CAACV,MAAM,CAACW,aAAa,CAACC,yBAAyB,CAAC,EAAE;cACjH;cACA,CAACnC,EAAE,GAAG,IAAI,CAAC0B,sBAAsB,MAAM,IAAI,IAAI1B,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAAC2B,eAAe,CAACzC,YAAY,CAACkD,2BAA2B,CAAC;cACpI,IAAI,CAACP,MAAM,CAACC,IAAI,CAAC,sGAAsG,GAAG,IAAI,CAACP,MAAM,CAACW,aAAa,CAACC,yBAAyB,GAAG,WAAW,CAAC;cAC5L,MAAM5C,eAAe,CAACwC,0BAA0B,EAAE;YACtD;YACAf,aAAa,GAAG,IAAI,CAACqB,0BAA0B,CAACvC,OAAO,EAAEiB,iBAAiB,CAACuB,aAAa,CAAC;YACzFpB,aAAa,GAAG,IAAI;YACpB,IAAIF,aAAa,EAAE;cACfC,aAAa,GAAG,IAAI3B,SAAS,CAAC0B,aAAa,CAACuB,MAAM,EAAE,IAAI,CAAChB,MAAM,CAACiB,eAAe,CAAC;cAChFrB,cAAc,GAAGF,aAAa,CAACwB,MAAM,CAACC,GAAG,GAAGzB,aAAa,CAACwB,MAAM,CAACC,GAAG,GAAGzB,aAAa,CAACwB,MAAM,CAACE,GAAG;cAC/FvB,WAAW,GAAG;gBACVkB,aAAa,EAAEtB,aAAa,CAACsB,aAAa;gBAC1CM,WAAW,EAAE5B,aAAa,CAAC4B,WAAW;gBACtCC,QAAQ,EAAE7B,aAAa,CAAC8B,KAAK;gBAC7BC,QAAQ,EAAE5D,SAAS,CAAC6D,YAAY;gBAChC7B,cAAc,EAAEA,cAAc,IAAIhC,SAAS,CAAC6D;cAChD,CAAC;cACD9B,aAAa,GAAG,IAAI,CAAC+B,YAAY,CAACC,oBAAoB,CAAC9B,WAAW,CAAC;YACvE;YACA;YACA,IAAI,IAAI,CAACG,MAAM,CAACG,sBAAsB,EAAE;cACpC,IAAI,CAACH,MAAM,CAACG,sBAAsB,CAACyB,kBAAkB,EAAE;YAC3D;YACA,OAAO,CAAC,CAAC,CAAC,WAAW/D,eAAe,CAACgE,4BAA4B,CAAC,IAAI,CAAChD,WAAW,EAAE,IAAI,CAACO,SAAS,EAAE;cAC5F0C,OAAO,EAAEnC,aAAa;cACtBoC,WAAW,EAAEvC,iBAAiB;cAC9BwC,OAAO,EAAEvC,aAAa;cACtBwC,YAAY,EAAE,IAAI;cAClBC,WAAW,EAAE;YACjB,CAAC,EAAE,IAAI,EAAE3D,OAAO,EAAEmB,aAAa,CAAC,CAAC;UACzC,KAAK,CAAC;YAAE,OAAO,CAAC,CAAC,CAAC,YAAYI,EAAE,CAACb,IAAI,EAAE,CAAC;QAAC;MAEjD,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;AACA;EACIhB,gBAAgB,CAACI,SAAS,CAACyC,0BAA0B,GAAG,UAAUvC,OAAO,EAAE4D,eAAe,EAAE;IACxF,IAAIC,aAAa,GAAG;MAChBrB,aAAa,EAAEoB,eAAe;MAC9Bd,WAAW,EAAE,IAAI,CAACjC,SAAS,CAACiD,+BAA+B,CAACC,eAAe;MAC3EC,cAAc,EAAE/E,cAAc,CAACgF,QAAQ;MACvCtC,QAAQ,EAAE,IAAI,CAACF,MAAM,CAACC,WAAW,CAACC,QAAQ;MAC1CqB,KAAK,EAAE,IAAI,CAACnC,SAAS,CAACqD;IAC1B,CAAC;IACD,IAAIC,eAAe,GAAG,IAAI,CAAChB,YAAY,CAACiB,wBAAwB,CAACP,aAAa,CAAC;IAC/E,IAAIQ,QAAQ,GAAGC,MAAM,CAACC,IAAI,CAACJ,eAAe,CAACE,QAAQ,CAAC,CAACG,GAAG,CAAC,UAAUC,GAAG,EAAE;MAAE,OAAON,eAAe,CAACE,QAAQ,CAACI,GAAG,CAAC;IAAE,CAAC,CAAC;IAClH;IACA,IAAIJ,QAAQ,CAACK,MAAM,GAAG,CAAC,EAAE;MACrB,OAAO,IAAI;IACf;IACA,OAAOL,QAAQ,CAAC,CAAC,CAAC;EACtB,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;EACI3E,gBAAgB,CAACI,SAAS,CAAC0B,8BAA8B,GAAG,UAAUG,QAAQ,EAAE3B,OAAO,EAAE;IACrF,IAAI2E,UAAU,GAAG3E,OAAO,CAAC4E,oBAAoB,IAAI5F,oBAAoB,CAAC6F,MAAM;IAC5E;AACR;AACA;AACA;IACQ,IAAIb,cAAc,GAAIW,UAAU,IAAIA,UAAU,CAACG,WAAW,EAAE,KAAK9F,oBAAoB,CAAC6F,MAAM,CAACC,WAAW,EAAE,GAAI7F,cAAc,CAAC8F,6BAA6B,GAAG9F,cAAc,CAAC+F,YAAY;IACxL,IAAIC,iBAAiB,GAAG;MACpBjB,cAAc,EAAEA,cAAc;MAC9BrC,QAAQ,EAAEA,QAAQ;MAClBuD,MAAM,EAAE,IAAI,CAAC9E,QAAQ,CAAC+E,oBAAoB,EAAE;MAC5CC,SAAS,EAAET,UAAU;MACrBU,KAAK,EAAErF,OAAO,CAACsF,MAAM;MACrBC,mBAAmB,EAAEvF,OAAO,CAACuF,mBAAmB;MAChD9E,iBAAiB,EAAE,IAAI,CAACA;IAC5B,CAAC;IACD,IAAI0D,eAAe,GAAG,IAAI,CAAChB,YAAY,CAACiB,wBAAwB,CAACa,iBAAiB,CAAC;IACnF,IAAIO,YAAY,GAAGlB,MAAM,CAACC,IAAI,CAACJ,eAAe,CAACqB,YAAY,CAAC,CAAChB,GAAG,CAAC,UAAUC,GAAG,EAAE;MAAE,OAAON,eAAe,CAACqB,YAAY,CAACf,GAAG,CAAC;IAAE,CAAC,CAAC;IAC9H,IAAIgB,eAAe,GAAGD,YAAY,CAACd,MAAM;IACzC,IAAIe,eAAe,GAAG,CAAC,EAAE;MACrB,OAAO,IAAI;IACf,CAAC,MACI,IAAIA,eAAe,GAAG,CAAC,EAAE;MAC1B,MAAMhG,eAAe,CAACiG,wCAAwC,EAAE;IACpE;IACA,OAAOF,YAAY,CAAC,CAAC,CAAC;EAC1B,CAAC;EACD;AACJ;AACA;AACA;AACA;EACI9F,gBAAgB,CAACI,SAAS,CAACc,mBAAmB,GAAG,UAAUZ,OAAO,EAAEa,SAAS,EAAEJ,iBAAiB,EAAE;IAC9F,OAAO9B,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,YAAY;MAC/C,IAAIgH,WAAW,EAAEC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAEC,QAAQ,EAAEC,eAAe,EAAEC,aAAa;MAC5F,OAAOrH,WAAW,CAAC,IAAI,EAAE,UAAUqB,EAAE,EAAE;QACnC,QAAQA,EAAE,CAACE,KAAK;UACZ,KAAK,CAAC;YACFwF,WAAW,GAAG,IAAI,CAACO,sBAAsB,CAAClG,OAAO,CAAC;YAClD4F,OAAO,GAAG,IAAI,CAACO,yBAAyB,EAAE;YAC1CN,UAAU,GAAG;cACTlE,QAAQ,EAAE,IAAI,CAACF,MAAM,CAACC,WAAW,CAACC,QAAQ;cAC1Cd,SAAS,EAAEb,OAAO,CAACa,SAAS;cAC5BR,MAAM,EAAEL,OAAO,CAACK,MAAM;cACtBsC,MAAM,EAAE3C,OAAO,CAAC2C,MAAM;cACtBiC,oBAAoB,EAAE5E,OAAO,CAAC4E,oBAAoB;cAClDwB,qBAAqB,EAAEpG,OAAO,CAACoG,qBAAqB;cACpDC,kBAAkB,EAAErG,OAAO,CAACqG,kBAAkB;cAC9CC,SAAS,EAAEtG,OAAO,CAACsG,SAAS;cAC5BhB,MAAM,EAAEtF,OAAO,CAACsF;YACpB,CAAC;YACDQ,YAAY,GAAGvG,SAAS,CAACgH,UAAU,EAAE;YACrC,OAAO,CAAC,CAAC,CAAC,WAAW,IAAI,CAACC,0BAA0B,CAAC3F,SAAS,CAAC4F,aAAa,EAAEd,WAAW,EAAEC,OAAO,EAAEC,UAAU,CAAC,CAAC;UACpH,KAAK,CAAC;YACFE,QAAQ,GAAG9F,EAAE,CAACS,IAAI,EAAE;YACpBsF,eAAe,GAAG,IAAI1G,eAAe,CAAC,IAAI,CAACmC,MAAM,CAACC,WAAW,CAACC,QAAQ,EAAE,IAAI,CAACwB,YAAY,EAAE,IAAI,CAAC7C,WAAW,EAAE,IAAI,CAACyB,MAAM,EAAE,IAAI,CAACN,MAAM,CAACiF,iBAAiB,EAAE,IAAI,CAACjF,MAAM,CAACkF,iBAAiB,CAAC;YACvLX,eAAe,CAACY,qBAAqB,CAACb,QAAQ,CAACc,IAAI,CAAC;YACpD,OAAO,CAAC,CAAC,CAAC,WAAWb,eAAe,CAACc,yBAAyB,CAACf,QAAQ,CAACc,IAAI,EAAE,IAAI,CAAChG,SAAS,EAAEiF,YAAY,EAAE9F,OAAO,EAAE+G,SAAS,EAAEtG,iBAAiB,CAAC,CAAC;UACvJ,KAAK,CAAC;YACFwF,aAAa,GAAGhG,EAAE,CAACS,IAAI,EAAE;YACzB,OAAO,CAAC,CAAC,CAAC,YAAYuF,aAAa,CAAC;QAAC;MAEjD,CAAC,CAAC;IACN,CAAC,CAAC;EACN,CAAC;EACD;AACJ;AACA;AACA;EACIvG,gBAAgB,CAACI,SAAS,CAACoG,sBAAsB,GAAG,UAAUlG,OAAO,EAAE;IACnE,IAAIgH,gBAAgB,GAAG,IAAIlI,uBAAuB,EAAE;IACpDkI,gBAAgB,CAACC,WAAW,CAAC,IAAI,CAACxF,MAAM,CAACC,WAAW,CAACC,QAAQ,CAAC;IAC9DqF,gBAAgB,CAACE,SAAS,CAAClH,OAAO,CAACK,MAAM,CAAC;IAC1C2G,gBAAgB,CAACG,YAAY,CAACjI,SAAS,CAACkI,UAAU,CAAC;IACnDJ,gBAAgB,CAACK,aAAa,EAAE;IAChCL,gBAAgB,CAACM,cAAc,CAAC,IAAI,CAAC7F,MAAM,CAAC8F,WAAW,CAAC;IACxDP,gBAAgB,CAACQ,uBAAuB,CAAC,IAAI,CAAC/F,MAAM,CAACgG,SAAS,CAACC,WAAW,CAAC;IAC3EV,gBAAgB,CAACW,aAAa,EAAE;IAChC,IAAI,IAAI,CAAC/F,sBAAsB,EAAE;MAC7BoF,gBAAgB,CAACY,kBAAkB,CAAC,IAAI,CAAChG,sBAAsB,CAAC;IACpE;IACA,IAAIiG,aAAa,GAAG7H,OAAO,CAAC6H,aAAa,IAAI,IAAI,CAACpG,MAAM,CAACiB,eAAe,CAACoF,aAAa,EAAE;IACxFd,gBAAgB,CAACe,gBAAgB,CAACF,aAAa,CAAC;IAChDb,gBAAgB,CAACgB,kBAAkB,CAAC7I,kBAAkB,CAAC8I,YAAY,CAAC;IACpEjB,gBAAgB,CAACkB,eAAe,CAAClI,OAAO,CAACQ,YAAY,CAAC;IACtD,IAAI,IAAI,CAACiB,MAAM,CAAC0G,iBAAiB,CAACC,YAAY,EAAE;MAC5CpB,gBAAgB,CAACqB,eAAe,CAAC,IAAI,CAAC5G,MAAM,CAAC0G,iBAAiB,CAACC,YAAY,CAAC;IAChF;IACA,IAAI,IAAI,CAAC3G,MAAM,CAAC0G,iBAAiB,CAACG,eAAe,EAAE;MAC/C,IAAIA,eAAe,GAAG,IAAI,CAAC7G,MAAM,CAAC0G,iBAAiB,CAACG,eAAe;MACnEtB,gBAAgB,CAACuB,kBAAkB,CAACD,eAAe,CAACE,SAAS,CAAC;MAC9DxB,gBAAgB,CAACyB,sBAAsB,CAACH,eAAe,CAACI,aAAa,CAAC;IAC1E;IACA,OAAO1B,gBAAgB,CAAC2B,iBAAiB,EAAE;EAC/C,CAAC;EACD,OAAOjJ,gBAAgB;AAC3B,CAAC,CAACb,UAAU,CAAE;AAEd,SAASa,gBAAgB"},"metadata":{},"sourceType":"module","externalDependencies":[]}