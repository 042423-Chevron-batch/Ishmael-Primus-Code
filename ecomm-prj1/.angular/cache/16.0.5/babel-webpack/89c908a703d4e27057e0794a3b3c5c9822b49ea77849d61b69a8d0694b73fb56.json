{"ast":null,"code":"/*! @azure/msal-browser v2.37.1 2023-06-07 */\n'use strict';\n\nimport { __extends, __awaiter, __generator, __spread } from '../_virtual/_tslib.js';\nimport { CredentialType, RefreshTokenEntity, CacheManager, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\nvar BrowserCacheManager = /** @class */function (_super) {\n  __extends(BrowserCacheManager, _super);\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl, logger) || this;\n    // Cookie life calculation (hours * minutes * seconds * ms)\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation);\n    // Migrate cache entries from older versions of MSAL.\n    if (cacheConfig.cacheMigrationEnabled) {\n      _this.migrateCacheEntries();\n      _this.createKeyMaps();\n    }\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n    }\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n   * @param temporaryCacheLocation\r\n   * @param cacheLocation\r\n   */\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          /*\r\n           * When users do not explicitly choose their own temporaryCacheLocation,\r\n           * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n           */\n          return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Searches all cache entries for MSAL accounts and creates the account key map\r\n   * This is used to migrate users from older versions of MSAL which did not create the map.\r\n   * @returns\r\n   */\n  BrowserCacheManager.prototype.createKeyMaps = function () {\n    var _this = this;\n    this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n    if (accountKeys && tokenKeys) {\n      this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\n      // Key maps already exist, no need to iterate through cache\n      return;\n    }\n    var allKeys = this.browserStorage.getKeys();\n    allKeys.forEach(function (key) {\n      if (_this.isCredentialKey(key)) {\n        // Get item, parse, validate and write key to map\n        var value = _this.getItem(key);\n        if (value) {\n          var credObj = _this.validateAndParseJson(value);\n          if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\n            switch (credObj[\"credentialType\"]) {\n              case CredentialType.ID_TOKEN:\n                if (IdTokenEntity.isIdTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \" + key + \" found, saving key to token key map\");\n                  var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\n                  var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);\n                  _this.addTokenKey(newKey, CredentialType.ID_TOKEN);\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \" + key);\n                }\n                break;\n              case CredentialType.ACCESS_TOKEN:\n              case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \" + key + \" found, saving key to token key map\");\n                  var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\n                  var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);\n                  _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \" + key);\n                }\n                break;\n              case CredentialType.REFRESH_TOKEN:\n                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \" + key + \" found, saving key to token key map\");\n                  var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\n                  var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);\n                  _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\n                  return;\n                } else {\n                  _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\n                  _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \" + key);\n                }\n                break;\n              // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\n            }\n          }\n        }\n      }\n\n      if (_this.isAccountKey(key)) {\n        var value = _this.getItem(key);\n        if (value) {\n          var accountObj = _this.validateAndParseJson(value);\n          if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\n            _this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\n            _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \" + key + \" found, saving key to account key map\");\n            _this.addAccountKeyToMap(key);\n          }\n        }\n      }\n    });\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    this.logger.trace(\"BrowserCacheManager.getAccount called\");\n    var account = this.getItem(accountKey);\n    if (!account) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    var parsedAccount = this.validateAndParseJson(account);\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      this.removeAccountKeyFromMap(accountKey);\n      return null;\n    }\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n    this.addAccountKeyToMap(key);\n  };\n  /**\r\n   * Returns the array of account keys currently cached\r\n   * @returns\r\n   */\n  BrowserCacheManager.prototype.getAccountKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\n    var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\n    if (accountKeys) {\n      return JSON.parse(accountKeys);\n    }\n    this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\n    return [];\n  };\n  /**\r\n   * Add a new account to the key map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n    if (accountKeys.indexOf(key) === -1) {\n      // Only add key if it does not already exist in the map\n      accountKeys.push(key);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\n    }\n  };\n  /**\r\n   * Remove an account from the key map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {\n    this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\n    this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \" + key);\n    var accountKeys = this.getAccountKeys();\n    var removalIndex = accountKeys.indexOf(key);\n    if (removalIndex > -1) {\n      accountKeys.splice(removalIndex, 1);\n      this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\n    } else {\n      this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\n    }\n  };\n  /**\r\n   * Extends inherited removeAccount function to include removal of the account key from the map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeAccount = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccount.call(this, key);\n        this.removeAccountKeyFromMap(key);\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\r\n   * Removes given idToken from the cache and from the key map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeIdToken = function (key) {\n    _super.prototype.removeIdToken.call(this, key);\n    this.removeTokenKey(key, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * Removes given accessToken from the cache and from the key map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeAccessToken = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        _super.prototype.removeAccessToken.call(this, key);\n        this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\n        return [2 /*return*/];\n      });\n    });\n  };\n  /**\r\n   * Removes given refreshToken from the cache and from the key map\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeRefreshToken = function (key) {\n    _super.prototype.removeRefreshToken.call(this, key);\n    this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * Gets the keys for the cached tokens associated with this clientId\r\n   * @returns\r\n   */\n  BrowserCacheManager.prototype.getTokenKeys = function () {\n    this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\n    var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\n    if (item) {\n      var tokenKeys = this.validateAndParseJson(item);\n      if (tokenKeys && tokenKeys.hasOwnProperty(\"idToken\") && tokenKeys.hasOwnProperty(\"accessToken\") && tokenKeys.hasOwnProperty(\"refreshToken\")) {\n        return tokenKeys;\n      } else {\n        this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\n      }\n    } else {\n      this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\n    }\n    return {\n      idToken: [],\n      accessToken: [],\n      refreshToken: []\n    };\n  };\n  /**\r\n   * Adds the given key to the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  BrowserCacheManager.prototype.addTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager addTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        if (tokenKeys.idToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\n          tokenKeys.idToken.push(key);\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        if (tokenKeys.accessToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\n          tokenKeys.accessToken.push(key);\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        if (tokenKeys.refreshToken.indexOf(key) === -1) {\n          this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\n          tokenKeys.refreshToken.push(key);\n        }\n        break;\n      default:\n        this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * Removes the given key from the token key map\r\n   * @param key\r\n   * @param type\r\n   */\n  BrowserCacheManager.prototype.removeTokenKey = function (key, type) {\n    this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\n    var tokenKeys = this.getTokenKeys();\n    switch (type) {\n      case CredentialType.ID_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \" + key + \" from map\");\n        var idRemoval = tokenKeys.idToken.indexOf(key);\n        if (idRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\n          tokenKeys.idToken.splice(idRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.ACCESS_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \" + key + \" from map\");\n        var accessRemoval = tokenKeys.accessToken.indexOf(key);\n        if (accessRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\n          tokenKeys.accessToken.splice(accessRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      case CredentialType.REFRESH_TOKEN:\n        this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \" + key + \" from map\");\n        var refreshRemoval = tokenKeys.refreshToken.indexOf(key);\n        if (refreshRemoval > -1) {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\n          tokenKeys.refreshToken.splice(refreshRemoval, 1);\n        } else {\n          this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\n        }\n        break;\n      default:\n        this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \" + type);\n        ClientAuthError.createUnexpectedCredentialTypeError();\n    }\n    this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    var parsedIdToken = this.validateAndParseJson(value);\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n    this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    var parsedAccessToken = this.validateAndParseJson(value);\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n    this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    var parsedRefreshToken = this.validateAndParseJson(value);\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n    this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n    var parsedMetadata = this.validateAndParseJson(value);\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n    return null;\n  };\n  /**\r\n   *\r\n   */\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   * Sets wrapper metadata in memory\r\n   * @param wrapperSKU\r\n   * @param wrapperVersion\r\n   */\n  BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\n    this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\n  };\n  /**\r\n   * Returns wrapper metadata from in-memory storage\r\n   */\n  BrowserCacheManager.prototype.getWrapperMetadata = function () {\n    var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\n    var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\n    return [sku, version];\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\n    if (!activeAccountValueFilters) {\n      // if new active account cache type isn't found, it's an old version, so look for that instead\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\n      var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n      var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\n      if (!activeAccountValueLocal) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n        return null;\n      }\n      var activeAccount = this.getAccountInfoByFilter({\n        localAccountId: activeAccountValueLocal\n      })[0] || null;\n      if (activeAccount) {\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\n        this.setActiveAccount(activeAccount);\n        return activeAccount;\n      }\n      return null;\n    }\n    var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\n    if (activeAccountValueObj) {\n      this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\n      return this.getAccountInfoByFilter({\n        homeAccountId: activeAccountValueObj.homeAccountId,\n        localAccountId: activeAccountValueObj.localAccountId\n      })[0] || null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\n    return null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\n    var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      var activeAccountValue = {\n        homeAccountId: account.homeAccountId,\n        localAccountId: account.localAccountId\n      };\n      this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\n      this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountKey);\n      this.browserStorage.removeItem(activeAccountKeyLocal);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n      return true;\n    });\n  };\n  /**\r\n   * Checks the cache for accounts matching loginHint or SID\r\n   * @param loginHint\r\n   * @param sid\r\n   */\n  BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\n    var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\n      if (sid) {\n        var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\n        return sid === accountSid;\n      }\n      if (loginHint) {\n        return loginHint === accountInfo.username;\n      }\n      return false;\n    });\n    if (matchingAccounts.length === 1) {\n      return matchingAccounts[0];\n    } else if (matchingAccounts.length > 1) {\n      throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\n    }\n    return null;\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n    var value = this.temporaryCacheStorage.getItem(key);\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL.\r\n   */\n  BrowserCacheManager.prototype.clear = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Removes all accounts and their credentials\n            return [4 /*yield*/, this.removeAllAccounts()];\n          case 1:\n            // Removes all accounts and their credentials\n            _a.sent();\n            this.removeAppMetadata();\n            // Removes all remaining MSAL cache items\n            this.getKeys().forEach(function (cacheKey) {\n              // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n              if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n                _this.removeItem(cacheKey);\n              }\n            });\n            this.internalStorage.clear();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n    return Constants.EMPTY_STRING;\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n  BrowserCacheManager.prototype.setCache = function () {\n    // sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n    if (!state) {\n      return null;\n    }\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\n    // Cache the request state\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false);\n    // Cache the nonce\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false);\n    // Cache authorityKey\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\n    // check state and remove associated cache items\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    }\n    // delete generic interactive request parameters\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\n    this.setInteractionInProgress(false);\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\n    // Interaction is completed - remove interaction status.\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\n    }\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\n    // Loop through all keys to find state key\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      }\n      // Retrieve state value, return if not a valid value\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n      if (!stateValue) {\n        return;\n      }\n      // Extract state and ensure it matches given InteractionType, then clean request cache\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n    this.setInteractionInProgress(false);\n  };\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\n    // Get token request from cache and parse as TokenExchangeParameters.\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    // Get cached authority and use if no authority is cached with request.\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n      parsedRequest.authority = cachedAuthority;\n    }\n    return parsedRequest;\n  };\n  /**\r\n   * Gets cached native request for redirect flows\r\n   */\n  BrowserCacheManager.prototype.getCachedNativeRequest = function () {\n    this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\n    var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\n    if (!cachedRequest) {\n      this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\n      return null;\n    }\n    var parsedRequest = this.validateAndParseJson(cachedRequest);\n    if (!parsedRequest) {\n      this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\n      return null;\n    }\n    return parsedRequest;\n  };\n  BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\n    var clientId = this.getInteractionInProgress();\n    if (matchClientId) {\n      return clientId === this.clientId;\n    } else {\n      return !!clientId;\n    }\n  };\n  BrowserCacheManager.prototype.getInteractionInProgress = function () {\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    return this.getTemporaryCache(key, false);\n  };\n  BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\n    // Ensure we don't overwrite interaction in progress for a different clientId\n    var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\n    if (inProgress) {\n      if (this.getInteractionInProgress()) {\n        throw BrowserAuthError.createInteractionInProgressError();\n      } else {\n        // No interaction is in progress\n        this.setTemporaryCache(key, this.clientId, false);\n      }\n    } else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\n      this.removeItem(key);\n    }\n  };\n  /**\r\n   * Returns username retrieved from ADAL or MSAL v1 idToken\r\n   */\n  BrowserCacheManager.prototype.getLegacyLoginHint = function () {\n    // Only check for adal/msal token if no SSO params are being used\n    var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n    if (adalIdTokenString) {\n      this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n      this.logger.verbose(\"Cached ADAL id token retrieved.\");\n    }\n    // Check for cached MSAL v1 id token\n    var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\n    if (msalIdTokenString) {\n      this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\n      this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\n    }\n    var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\n    if (cachedIdTokenString) {\n      var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\n      if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\n        return cachedIdToken.claims.preferred_username;\n      } else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\n        return cachedIdToken.claims.upn;\n      } else {\n        this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\n      }\n    }\n    return null;\n  };\n  /**\r\n   * Updates a credential's cache key if the current cache key is outdated\r\n   */\n  BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\n    var updatedCacheKey = credential.generateCredentialKey();\n    if (currentCacheKey !== updatedCacheKey) {\n      var cacheItem = this.getItem(currentCacheKey);\n      if (cacheItem) {\n        this.removeItem(currentCacheKey);\n        this.setItem(updatedCacheKey, cacheItem);\n        this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\n        return updatedCacheKey;\n      } else {\n        this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\n      }\n    }\n    return currentCacheKey;\n  };\n  /**\r\n   * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n   */\n  BrowserCacheManager.prototype.getRedirectRequestContext = function () {\n    return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\n  };\n  /**\r\n   * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n   * @param value\r\n   */\n  BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\n    this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\n  };\n  return BrowserCacheManager;\n}(CacheManager);\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false,\n    cacheMigrationEnabled: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"names":["__extends","__awaiter","__generator","__spread","CredentialType","RefreshTokenEntity","CacheManager","AccessTokenEntity","IdTokenEntity","AccountEntity","ClientAuthError","AppMetadataEntity","ServerTelemetryEntity","AuthorityMetadataEntity","Constants","PersistentCacheKeys","ThrottlingEntity","StringUtils","ProtocolUtils","CcsCredentialType","IdToken","DEFAULT_CRYPTO_IMPLEMENTATION","BrowserAuthError","BrowserCacheLocation","StaticCacheKeys","InMemoryCacheKeys","TemporaryCacheKeys","BrowserStorage","MemoryStorage","BrowserProtocolUtils","BrowserCacheManager","_super","clientId","cacheConfig","cryptoImpl","logger","_this","call","COOKIE_LIFE_MULTIPLIER","internalStorage","browserStorage","setupBrowserStorage","cacheLocation","temporaryCacheStorage","setupTemporaryCacheStorage","temporaryCacheLocation","cacheMigrationEnabled","migrateCacheEntries","createKeyMaps","prototype","LocalStorage","SessionStorage","e","verbose","idTokenKey","CACHE_PREFIX","ID_TOKEN","clientInfoKey","CLIENT_INFO","errorKey","ERROR","errorDescKey","ERROR_DESC","idTokenValue","getItem","clientInfoValue","errorValue","errorDescValue","values","keysToMigrate","forEach","cacheKey","index","migrateCacheEntry","newKey","value","setTemporaryCache","trace","accountKeys","ACCOUNT_KEYS","tokenKeys","TOKEN_KEYS","allKeys","getKeys","key","isCredentialKey","credObj","validateAndParseJson","hasOwnProperty","isIdTokenEntity","tracePii","idTokenEntity","toObject","updateCredentialCacheKey","addTokenKey","ACCESS_TOKEN","ACCESS_TOKEN_WITH_AUTH_SCHEME","isAccessTokenEntity","accessTokenEntity","REFRESH_TOKEN","isRefreshTokenEntity","refreshTokenEntity","isAccountKey","accountObj","isAccountEntity","addAccountKeyToMap","jsonValue","parsedJson","JSON","parse","error","setItem","getAccount","accountKey","account","removeAccountKeyFromMap","parsedAccount","setAccount","generateAccountKey","stringify","getAccountKeys","indexOf","push","removalIndex","splice","removeAccount","_a","removeIdToken","removeTokenKey","removeAccessToken","removeRefreshToken","getTokenKeys","item","idToken","accessToken","refreshToken","type","info","createUnexpectedCredentialTypeError","infoPii","idRemoval","accessRemoval","refreshRemoval","getIdTokenCredential","parsedIdToken","setIdTokenCredential","generateCredentialKey","getAccessTokenCredential","accessTokenKey","parsedAccessToken","setAccessTokenCredential","getRefreshTokenCredential","refreshTokenKey","parsedRefreshToken","setRefreshTokenCredential","getAppMetadata","appMetadataKey","parsedMetadata","isAppMetadataEntity","setAppMetadata","appMetadata","generateAppMetadataKey","getServerTelemetry","serverTelemetryKey","isServerTelemetryEntity","setServerTelemetry","serverTelemetry","getAuthorityMetadata","isAuthorityMetadataEntity","getAuthorityMetadataKeys","filter","isAuthorityMetadata","setWrapperMetadata","wrapperSKU","wrapperVersion","WRAPPER_SKU","WRAPPER_VER","getWrapperMetadata","sku","EMPTY_STRING","version","setAuthorityMetadata","entity","getActiveAccount","activeAccountKeyFilters","generateCacheKey","ACTIVE_ACCOUNT_FILTERS","activeAccountValueFilters","activeAccountKeyLocal","ACTIVE_ACCOUNT","activeAccountValueLocal","activeAccount","getAccountInfoByFilter","localAccountId","setActiveAccount","activeAccountValueObj","homeAccountId","activeAccountKey","activeAccountValue","removeItem","accountFilter","allAccounts","getAllAccounts","length","username","toLowerCase","tenantId","environment","getAccountInfoByHints","loginHint","sid","matchingAccounts","accountInfo","accountSid","idTokenClaims","createMultipleMatchingAccountsInCacheError","getThrottlingCache","throttlingCacheKey","parsedThrottlingCache","isThrottlingEntity","setThrottlingCache","throttlingCache","getTemporaryCache","generateKey","storeAuthStateInCookie","itemCookie","getItemCookie","setItemCookie","clearItemCookie","containsKey","clear","label","removeAllAccounts","sent","removeAppMetadata","cookieName","cookieValue","expires","cookieStr","encodeURIComponent","expireTime","getCookieExpirationTime","secureCookies","document","cookie","name","cookieList","split","i","charAt","substring","decodeURIComponent","clearMsalCookies","cookiePrefix","cookieKey","cookieLifeDays","today","Date","expr","getTime","toUTCString","getCache","setCache","generatedKey","startsWith","ADAL_ID_TOKEN","generateAuthorityKey","stateString","stateId","parseRequestState","libraryState","id","AUTHORITY","generateNonceKey","NONCE_IDTOKEN","generateStateKey","REQUEST_STATE","getCachedAuthority","cachedState","stateCacheKey","state","authorityCacheKey","updateCacheEntries","nonce","authorityInstance","nonceCacheKey","ccsCredential","credential","HOME_ACCOUNT_ID","CCS_CREDENTIAL","isEmpty","UPN","resetRequestCache","REQUEST_PARAMS","ORIGIN_URI","URL_HASH","CORRELATION_ID","NATIVE_REQUEST","setInteractionInProgress","cleanRequestByState","stateKey","cleanRequestByInteractionType","interactionType","stateValue","parsedState","extractBrowserRequestState","cacheCodeRequest","authCodeRequest","browserCrypto","encodedValue","base64Encode","getCachedRequest","encodedTokenRequest","createNoTokenRequestCacheError","parsedRequest","base64Decode","createUnableToParseTokenRequestCacheError","authority","cachedAuthority","createNoCachedAuthorityError","getCachedNativeRequest","cachedRequest","isInteractionInProgress","matchClientId","getInteractionInProgress","INTERACTION_STATUS_KEY","inProgress","createInteractionInProgressError","getLegacyLoginHint","adalIdTokenString","msalIdTokenString","cachedIdTokenString","cachedIdToken","claims","preferred_username","upn","currentCacheKey","updatedCacheKey","cacheItem","credentialType","getRedirectRequestContext","REDIRECT_CONTEXT","setRedirectRequestContext","DEFAULT_BROWSER_CACHE_MANAGER","cacheOptions"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/msal-browser/dist/cache/BrowserCacheManager.js"],"sourcesContent":["/*! @azure/msal-browser v2.37.1 2023-06-07 */\n'use strict';\nimport { __extends, __awaiter, __generator, __spread } from '../_virtual/_tslib.js';\nimport { CredentialType, RefreshTokenEntity, CacheManager, AccessTokenEntity, IdTokenEntity, AccountEntity, ClientAuthError, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, Constants, PersistentCacheKeys, ThrottlingEntity, StringUtils, ProtocolUtils, CcsCredentialType, IdToken, DEFAULT_CRYPTO_IMPLEMENTATION } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, StaticCacheKeys, InMemoryCacheKeys, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nvar BrowserCacheManager = /** @class */ (function (_super) {\r\n    __extends(BrowserCacheManager, _super);\r\n    function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\r\n        var _this = _super.call(this, clientId, cryptoImpl, logger) || this;\r\n        // Cookie life calculation (hours * minutes * seconds * ms)\r\n        _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\r\n        _this.cacheConfig = cacheConfig;\r\n        _this.logger = logger;\r\n        _this.internalStorage = new MemoryStorage();\r\n        _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\r\n        _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.temporaryCacheLocation, _this.cacheConfig.cacheLocation);\r\n        // Migrate cache entries from older versions of MSAL.\r\n        if (cacheConfig.cacheMigrationEnabled) {\r\n            _this.migrateCacheEntries();\r\n            _this.createKeyMaps();\r\n        }\r\n        return _this;\r\n    }\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n     * @param cacheLocation\r\n     */\r\n    BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    return new BrowserStorage(cacheLocation);\r\n                }\r\n                catch (e) {\r\n                    this.logger.verbose(e);\r\n                    break;\r\n                }\r\n        }\r\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\r\n        return new MemoryStorage();\r\n    };\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured temporaryCacheLocation.\r\n     * @param temporaryCacheLocation\r\n     * @param cacheLocation\r\n     */\r\n    BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (temporaryCacheLocation, cacheLocation) {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    /*\r\n                     * When users do not explicitly choose their own temporaryCacheLocation,\r\n                     * temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                     */\r\n                    return new BrowserStorage(temporaryCacheLocation || BrowserCacheLocation.SessionStorage);\r\n                }\r\n                catch (e) {\r\n                    this.logger.verbose(e);\r\n                    return this.internalStorage;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                return this.internalStorage;\r\n        }\r\n    };\r\n    /**\r\n     * Migrate all old cache entries to new schema. No rollback supported.\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    BrowserCacheManager.prototype.migrateCacheEntries = function () {\r\n        var _this = this;\r\n        var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\r\n        var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\r\n        var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\r\n        var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\r\n        var idTokenValue = this.browserStorage.getItem(idTokenKey);\r\n        var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\r\n        var errorValue = this.browserStorage.getItem(errorKey);\r\n        var errorDescValue = this.browserStorage.getItem(errorDescKey);\r\n        var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\r\n        keysToMigrate.forEach(function (cacheKey, index) { return _this.migrateCacheEntry(cacheKey, values[index]); });\r\n    };\r\n    /**\r\n     * Utility function to help with migration.\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\r\n        if (value) {\r\n            this.setTemporaryCache(newKey, value, true);\r\n        }\r\n    };\r\n    /**\r\n     * Searches all cache entries for MSAL accounts and creates the account key map\r\n     * This is used to migrate users from older versions of MSAL which did not create the map.\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.createKeyMaps = function () {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager - createKeyMaps called.\");\r\n        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        var tokenKeys = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\r\n        if (accountKeys && tokenKeys) {\r\n            this.logger.verbose(\"BrowserCacheManager:createKeyMaps - account and token key maps already exist, skipping migration.\");\r\n            // Key maps already exist, no need to iterate through cache\r\n            return;\r\n        }\r\n        var allKeys = this.browserStorage.getKeys();\r\n        allKeys.forEach(function (key) {\r\n            if (_this.isCredentialKey(key)) {\r\n                // Get item, parse, validate and write key to map\r\n                var value = _this.getItem(key);\r\n                if (value) {\r\n                    var credObj = _this.validateAndParseJson(value);\r\n                    if (credObj && credObj.hasOwnProperty(\"credentialType\")) {\r\n                        switch (credObj[\"credentialType\"]) {\r\n                            case CredentialType.ID_TOKEN:\r\n                                if (IdTokenEntity.isIdTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - idToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - idToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var idTokenEntity = CacheManager.toObject(new IdTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, idTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.ID_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching idToken schema with value containing idToken credentialType field but value failed IdTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed idToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            case CredentialType.ACCESS_TOKEN:\r\n                            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                                if (AccessTokenEntity.isAccessTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - accessToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - accessToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var accessTokenEntity = CacheManager.toObject(new AccessTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, accessTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.ACCESS_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching accessToken schema with value containing accessToken credentialType field but value failed AccessTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed accessToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            case CredentialType.REFRESH_TOKEN:\r\n                                if (RefreshTokenEntity.isRefreshTokenEntity(credObj)) {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - refreshToken found, saving key to token key map\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - refreshToken with key: \" + key + \" found, saving key to token key map\");\r\n                                    var refreshTokenEntity = CacheManager.toObject(new RefreshTokenEntity(), credObj);\r\n                                    var newKey = _this.updateCredentialCacheKey(key, refreshTokenEntity);\r\n                                    _this.addTokenKey(newKey, CredentialType.REFRESH_TOKEN);\r\n                                    return;\r\n                                }\r\n                                else {\r\n                                    _this.logger.trace(\"BrowserCacheManager:createKeyMaps - key found matching refreshToken schema with value containing refreshToken credentialType field but value failed RefreshTokenEntity validation, skipping.\");\r\n                                    _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - failed refreshToken validation on key: \" + key);\r\n                                }\r\n                                break;\r\n                            // If credentialType isn't one of our predefined ones, it may not be an MSAL cache value. Ignore.\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (_this.isAccountKey(key)) {\r\n                var value = _this.getItem(key);\r\n                if (value) {\r\n                    var accountObj = _this.validateAndParseJson(value);\r\n                    if (accountObj && AccountEntity.isAccountEntity(accountObj)) {\r\n                        _this.logger.trace(\"BrowserCacheManager:createKeyMaps - account found, saving key to account key map\");\r\n                        _this.logger.tracePii(\"BrowserCacheManager:createKeyMaps - account with key: \" + key + \" found, saving key to account key map\");\r\n                        _this.addAccountKeyToMap(key);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\r\n        try {\r\n            var parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\r\n        }\r\n        catch (error) {\r\n            return null;\r\n        }\r\n    };\r\n    /**\r\n     * fetches the entry from the browser storage based off the key\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getItem = function (key) {\r\n        return this.browserStorage.getItem(key);\r\n    };\r\n    /**\r\n     * sets the entry in the browser storage\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setItem = function (key, value) {\r\n        this.browserStorage.setItem(key, value);\r\n    };\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     * @param accountKey\r\n     */\r\n    BrowserCacheManager.prototype.getAccount = function (accountKey) {\r\n        this.logger.trace(\"BrowserCacheManager.getAccount called\");\r\n        var account = this.getItem(accountKey);\r\n        if (!account) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n        var parsedAccount = this.validateAndParseJson(account);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            this.removeAccountKeyFromMap(accountKey);\r\n            return null;\r\n        }\r\n        return CacheManager.toObject(new AccountEntity(), parsedAccount);\r\n    };\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setAccount = function (account) {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        var key = account.generateAccountKey();\r\n        this.setItem(key, JSON.stringify(account));\r\n        this.addAccountKeyToMap(key);\r\n    };\r\n    /**\r\n     * Returns the array of account keys currently cached\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.getAccountKeys = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getAccountKeys called\");\r\n        var accountKeys = this.getItem(StaticCacheKeys.ACCOUNT_KEYS);\r\n        if (accountKeys) {\r\n            return JSON.parse(accountKeys);\r\n        }\r\n        this.logger.verbose(\"BrowserCacheManager.getAccountKeys - No account keys found\");\r\n        return [];\r\n    };\r\n    /**\r\n     * Add a new account to the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.addAccountKeyToMap = function (key) {\r\n        this.logger.trace(\"BrowserCacheManager.addAccountKeyToMap called\");\r\n        this.logger.tracePii(\"BrowserCacheManager.addAccountKeyToMap called with key: \" + key);\r\n        var accountKeys = this.getAccountKeys();\r\n        if (accountKeys.indexOf(key) === -1) {\r\n            // Only add key if it does not already exist in the map\r\n            accountKeys.push(key);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key added\");\r\n        }\r\n        else {\r\n            this.logger.verbose(\"BrowserCacheManager.addAccountKeyToMap account key already exists in map\");\r\n        }\r\n    };\r\n    /**\r\n     * Remove an account from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccountKeyFromMap = function (key) {\r\n        this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap called\");\r\n        this.logger.tracePii(\"BrowserCacheManager.removeAccountKeyFromMap called with key: \" + key);\r\n        var accountKeys = this.getAccountKeys();\r\n        var removalIndex = accountKeys.indexOf(key);\r\n        if (removalIndex > -1) {\r\n            accountKeys.splice(removalIndex, 1);\r\n            this.setItem(StaticCacheKeys.ACCOUNT_KEYS, JSON.stringify(accountKeys));\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap account key removed\");\r\n        }\r\n        else {\r\n            this.logger.trace(\"BrowserCacheManager.removeAccountKeyFromMap key not found in existing map\");\r\n        }\r\n    };\r\n    /**\r\n     * Extends inherited removeAccount function to include removal of the account key from the map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccount = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                _super.prototype.removeAccount.call(this, key);\r\n                this.removeAccountKeyFromMap(key);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes given idToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeIdToken = function (key) {\r\n        _super.prototype.removeIdToken.call(this, key);\r\n        this.removeTokenKey(key, CredentialType.ID_TOKEN);\r\n    };\r\n    /**\r\n     * Removes given accessToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeAccessToken = function (key) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                _super.prototype.removeAccessToken.call(this, key);\r\n                this.removeTokenKey(key, CredentialType.ACCESS_TOKEN);\r\n                return [2 /*return*/];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Removes given refreshToken from the cache and from the key map\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeRefreshToken = function (key) {\r\n        _super.prototype.removeRefreshToken.call(this, key);\r\n        this.removeTokenKey(key, CredentialType.REFRESH_TOKEN);\r\n    };\r\n    /**\r\n     * Gets the keys for the cached tokens associated with this clientId\r\n     * @returns\r\n     */\r\n    BrowserCacheManager.prototype.getTokenKeys = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getTokenKeys called\");\r\n        var item = this.getItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId);\r\n        if (item) {\r\n            var tokenKeys = this.validateAndParseJson(item);\r\n            if (tokenKeys &&\r\n                tokenKeys.hasOwnProperty(\"idToken\") &&\r\n                tokenKeys.hasOwnProperty(\"accessToken\") &&\r\n                tokenKeys.hasOwnProperty(\"refreshToken\")) {\r\n                return tokenKeys;\r\n            }\r\n            else {\r\n                this.logger.error(\"BrowserCacheManager.getTokenKeys - Token keys found but in an unknown format. Returning empty key map.\");\r\n            }\r\n        }\r\n        else {\r\n            this.logger.verbose(\"BrowserCacheManager.getTokenKeys - No token keys found\");\r\n        }\r\n        return {\r\n            idToken: [],\r\n            accessToken: [],\r\n            refreshToken: []\r\n        };\r\n    };\r\n    /**\r\n     * Adds the given key to the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    BrowserCacheManager.prototype.addTokenKey = function (key, type) {\r\n        this.logger.trace(\"BrowserCacheManager addTokenKey called\");\r\n        var tokenKeys = this.getTokenKeys();\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                if (tokenKeys.idToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - idToken added to map\");\r\n                    tokenKeys.idToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                if (tokenKeys.accessToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - accessToken added to map\");\r\n                    tokenKeys.accessToken.push(key);\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                if (tokenKeys.refreshToken.indexOf(key) === -1) {\r\n                    this.logger.info(\"BrowserCacheManager: addTokenKey - refreshToken added to map\");\r\n                    tokenKeys.refreshToken.push(key);\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\"BrowserCacheManager:addTokenKey - CredentialType provided invalid. CredentialType: \" + type);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n        this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\r\n    };\r\n    /**\r\n     * Removes the given key from the token key map\r\n     * @param key\r\n     * @param type\r\n     */\r\n    BrowserCacheManager.prototype.removeTokenKey = function (key, type) {\r\n        this.logger.trace(\"BrowserCacheManager removeTokenKey called\");\r\n        var tokenKeys = this.getTokenKeys();\r\n        switch (type) {\r\n            case CredentialType.ID_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove idToken with key: \" + key + \" from map\");\r\n                var idRemoval = tokenKeys.idToken.indexOf(key);\r\n                if (idRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken removed from map\");\r\n                    tokenKeys.idToken.splice(idRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - idToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.ACCESS_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove accessToken with key: \" + key + \" from map\");\r\n                var accessRemoval = tokenKeys.accessToken.indexOf(key);\r\n                if (accessRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken removed from map\");\r\n                    tokenKeys.accessToken.splice(accessRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - accessToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            case CredentialType.REFRESH_TOKEN:\r\n                this.logger.infoPii(\"BrowserCacheManager: removeTokenKey - attempting to remove refreshToken with key: \" + key + \" from map\");\r\n                var refreshRemoval = tokenKeys.refreshToken.indexOf(key);\r\n                if (refreshRemoval > -1) {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken removed from map\");\r\n                    tokenKeys.refreshToken.splice(refreshRemoval, 1);\r\n                }\r\n                else {\r\n                    this.logger.info(\"BrowserCacheManager: removeTokenKey - refreshToken does not exist in map. Either it was previously removed or it was never added.\");\r\n                }\r\n                break;\r\n            default:\r\n                this.logger.error(\"BrowserCacheManager:removeTokenKey - CredentialType provided invalid. CredentialType: \" + type);\r\n                ClientAuthError.createUnexpectedCredentialTypeError();\r\n        }\r\n        this.setItem(StaticCacheKeys.TOKEN_KEYS + \".\" + this.clientId, JSON.stringify(tokenKeys));\r\n    };\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\r\n        var value = this.getItem(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\r\n    };\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        var idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, JSON.stringify(idToken));\r\n        this.addTokenKey(idTokenKey, CredentialType.ID_TOKEN);\r\n    };\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\r\n        var value = this.getItem(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedAccessToken = this.validateAndParseJson(value);\r\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\r\n    };\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\r\n        var accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\r\n        this.addTokenKey(accessTokenKey, CredentialType.ACCESS_TOKEN);\r\n    };\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\r\n        var value = this.getItem(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        var parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            this.removeTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\r\n    };\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\r\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\r\n        var refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\r\n        this.addTokenKey(refreshTokenKey, CredentialType.REFRESH_TOKEN);\r\n    };\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\r\n        var value = this.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\r\n    };\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        var appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\r\n    };\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\r\n        var value = this.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\r\n    };\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\r\n        var value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedMetadata = this.validateAndParseJson(value);\r\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\r\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     *\r\n     */\r\n    BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\r\n        var _this = this;\r\n        var allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter(function (key) {\r\n            return _this.isAuthorityMetadata(key);\r\n        });\r\n    };\r\n    /**\r\n     * Sets wrapper metadata in memory\r\n     * @param wrapperSKU\r\n     * @param wrapperVersion\r\n     */\r\n    BrowserCacheManager.prototype.setWrapperMetadata = function (wrapperSKU, wrapperVersion) {\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_SKU, wrapperSKU);\r\n        this.internalStorage.setItem(InMemoryCacheKeys.WRAPPER_VER, wrapperVersion);\r\n    };\r\n    /**\r\n     * Returns wrapper metadata from in-memory storage\r\n     */\r\n    BrowserCacheManager.prototype.getWrapperMetadata = function () {\r\n        var sku = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_SKU) || Constants.EMPTY_STRING;\r\n        var version = this.internalStorage.getItem(InMemoryCacheKeys.WRAPPER_VER) || Constants.EMPTY_STRING;\r\n        return [sku, version];\r\n    };\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    };\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    BrowserCacheManager.prototype.getActiveAccount = function () {\r\n        var activeAccountKeyFilters = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        var activeAccountValueFilters = this.getItem(activeAccountKeyFilters);\r\n        if (!activeAccountValueFilters) {\r\n            // if new active account cache type isn't found, it's an old version, so look for that instead\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account filters cache schema found, looking for legacy schema\");\r\n            var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n            var activeAccountValueLocal = this.getItem(activeAccountKeyLocal);\r\n            if (!activeAccountValueLocal) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n                return null;\r\n            }\r\n            var activeAccount = this.getAccountInfoByFilter({ localAccountId: activeAccountValueLocal })[0] || null;\r\n            if (activeAccount) {\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Legacy active account cache schema found\");\r\n                this.logger.trace(\"BrowserCacheManager.getActiveAccount: Adding active account filters cache schema\");\r\n                this.setActiveAccount(activeAccount);\r\n                return activeAccount;\r\n            }\r\n            return null;\r\n        }\r\n        var activeAccountValueObj = this.validateAndParseJson(activeAccountValueFilters);\r\n        if (activeAccountValueObj) {\r\n            this.logger.trace(\"BrowserCacheManager.getActiveAccount: Active account filters schema found\");\r\n            return this.getAccountInfoByFilter({\r\n                homeAccountId: activeAccountValueObj.homeAccountId,\r\n                localAccountId: activeAccountValueObj.localAccountId\r\n            })[0] || null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getActiveAccount: No active account found\");\r\n        return null;\r\n    };\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.setActiveAccount = function (account) {\r\n        var activeAccountKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT_FILTERS);\r\n        var activeAccountKeyLocal = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            var activeAccountValue = {\r\n                homeAccountId: account.homeAccountId,\r\n                localAccountId: account.localAccountId\r\n            };\r\n            this.browserStorage.setItem(activeAccountKey, JSON.stringify(activeAccountValue));\r\n            this.browserStorage.setItem(activeAccountKeyLocal, account.localAccountId);\r\n        }\r\n        else {\r\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\r\n            this.browserStorage.removeItem(activeAccountKey);\r\n            this.browserStorage.removeItem(activeAccountKeyLocal);\r\n        }\r\n    };\r\n    /**\r\n     * Gets a list of accounts that match all of the filters provided\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\r\n        var allAccounts = this.getAllAccounts();\r\n        this.logger.trace(\"BrowserCacheManager.getAccountInfoByFilter: total \" + allAccounts.length + \" accounts found\");\r\n        return allAccounts.filter(function (accountObj) {\r\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\r\n                return false;\r\n            }\r\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\r\n                return false;\r\n            }\r\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Checks the cache for accounts matching loginHint or SID\r\n     * @param loginHint\r\n     * @param sid\r\n     */\r\n    BrowserCacheManager.prototype.getAccountInfoByHints = function (loginHint, sid) {\r\n        var matchingAccounts = this.getAllAccounts().filter(function (accountInfo) {\r\n            if (sid) {\r\n                var accountSid = accountInfo.idTokenClaims && accountInfo.idTokenClaims[\"sid\"];\r\n                return sid === accountSid;\r\n            }\r\n            if (loginHint) {\r\n                return loginHint === accountInfo.username;\r\n            }\r\n            return false;\r\n        });\r\n        if (matchingAccounts.length === 1) {\r\n            return matchingAccounts[0];\r\n        }\r\n        else if (matchingAccounts.length > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAccountsInCacheError();\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\r\n        var value = this.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n        var parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\r\n    };\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\r\n    };\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\r\n        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            var itemCookie = this.getItemCookie(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\r\n                return itemCookie;\r\n            }\r\n        }\r\n        var value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\r\n                var item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\r\n        return value;\r\n    };\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\r\n        var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\r\n            this.setItemCookie(key, value);\r\n        }\r\n    };\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.removeItem = function (key) {\r\n        this.browserStorage.removeItem(key);\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\r\n            this.clearItemCookie(key);\r\n        }\r\n    };\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     */\r\n    BrowserCacheManager.prototype.containsKey = function (key) {\r\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\r\n    };\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    BrowserCacheManager.prototype.getKeys = function () {\r\n        return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\r\n    };\r\n    /**\r\n     * Clears all cache entries created by MSAL.\r\n     */\r\n    BrowserCacheManager.prototype.clear = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: \r\n                    // Removes all accounts and their credentials\r\n                    return [4 /*yield*/, this.removeAllAccounts()];\r\n                    case 1:\r\n                        // Removes all accounts and their credentials\r\n                        _a.sent();\r\n                        this.removeAppMetadata();\r\n                        // Removes all remaining MSAL cache items\r\n                        this.getKeys().forEach(function (cacheKey) {\r\n                            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\r\n                            if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(_this.clientId) !== -1))) {\r\n                                _this.removeItem(cacheKey);\r\n                            }\r\n                        });\r\n                        this.internalStorage.clear();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add value to cookies\r\n     * @param cookieName\r\n     * @param cookieValue\r\n     * @param expires\r\n     */\r\n    BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\r\n        var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;SameSite=Lax;\";\r\n        if (expires) {\r\n            var expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += \"expires=\" + expireTime + \";\";\r\n        }\r\n        if (this.cacheConfig.secureCookies) {\r\n            cookieStr += \"Secure;\";\r\n        }\r\n        document.cookie = cookieStr;\r\n    };\r\n    /**\r\n     * Get one item by key from cookies\r\n     * @param cookieName\r\n     */\r\n    BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\r\n        var name = encodeURIComponent(cookieName) + \"=\";\r\n        var cookieList = document.cookie.split(\";\");\r\n        for (var i = 0; i < cookieList.length; i++) {\r\n            var cookie = cookieList[i];\r\n            while (cookie.charAt(0) === \" \") {\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(name) === 0) {\r\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\r\n            }\r\n        }\r\n        return Constants.EMPTY_STRING;\r\n    };\r\n    /**\r\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n     */\r\n    BrowserCacheManager.prototype.clearMsalCookies = function () {\r\n        var _this = this;\r\n        var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\r\n        var cookieList = document.cookie.split(\";\");\r\n        cookieList.forEach(function (cookie) {\r\n            while (cookie.charAt(0) === \" \") {\r\n                // eslint-disable-next-line no-param-reassign\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(cookiePrefix) === 0) {\r\n                var cookieKey = cookie.split(\"=\")[0];\r\n                _this.clearItemCookie(cookieKey);\r\n            }\r\n        });\r\n    };\r\n    /**\r\n     * Clear an item in the cookies by key\r\n     * @param cookieName\r\n     */\r\n    BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\r\n        this.setItemCookie(cookieName, Constants.EMPTY_STRING, -1);\r\n    };\r\n    /**\r\n     * Get cookie expiration time\r\n     * @param cookieLifeDays\r\n     */\r\n    BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\r\n        var today = new Date();\r\n        var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\r\n        return expr.toUTCString();\r\n    };\r\n    /**\r\n     * Gets the cache object referenced by the browser\r\n     */\r\n    BrowserCacheManager.prototype.getCache = function () {\r\n        return this.browserStorage;\r\n    };\r\n    /**\r\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n     */\r\n    BrowserCacheManager.prototype.setCache = function () {\r\n        // sets nothing\r\n    };\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    BrowserCacheManager.prototype.generateCacheKey = function (key) {\r\n        var generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\r\n                return key;\r\n            }\r\n            return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\r\n        }\r\n        return JSON.stringify(key);\r\n    };\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    BrowserCacheManager.prototype.generateStateKey = function (stateString) {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\r\n        return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\r\n    };\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\r\n        var stateCacheKey = this.generateStateKey(cachedState);\r\n        var state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n        var authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    };\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        var stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n        // Cache the nonce\r\n        var nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n        // Cache authorityKey\r\n        var authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n        if (account) {\r\n            var ccsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n        else if (!StringUtils.isEmpty(loginHint)) {\r\n            var ccsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n    };\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    BrowserCacheManager.prototype.resetRequestCache = function (state) {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.getKeys().forEach(function (key) {\r\n                if (key.indexOf(state) !== -1) {\r\n                    _this.removeItem(key);\r\n                }\r\n            });\r\n        }\r\n        // delete generic interactive request parameters\r\n        if (state) {\r\n            this.removeItem(this.generateStateKey(state));\r\n            this.removeItem(this.generateNonceKey(state));\r\n            this.removeItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CORRELATION_ID));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.NATIVE_REQUEST));\r\n        this.setInteractionInProgress(false);\r\n    };\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString\r\n     */\r\n    BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            var stateKey = this.generateStateKey(stateString);\r\n            var cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\r\n            this.resetRequestCache(cachedState || Constants.EMPTY_STRING);\r\n        }\r\n        this.clearMsalCookies();\r\n    };\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType\r\n     */\r\n    BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\r\n        var _this = this;\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\r\n        // Loop through all keys to find state key\r\n        this.getKeys().forEach(function (key) {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n            // Retrieve state value, return if not a valid value\r\n            var stateValue = _this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\r\n            if (parsedState && parsedState.interactionType === interactionType) {\r\n                _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\r\n                _this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.clearMsalCookies();\r\n        this.setInteractionInProgress(false);\r\n    };\r\n    BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n        var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\r\n    };\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\r\n        if (!encodedTokenRequest) {\r\n            throw BrowserAuthError.createNoTokenRequestCacheError();\r\n        }\r\n        var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\r\n        if (!parsedRequest) {\r\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\r\n            var authorityCacheKey = this.generateAuthorityKey(state);\r\n            var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n        return parsedRequest;\r\n    };\r\n    /**\r\n     * Gets cached native request for redirect flows\r\n     */\r\n    BrowserCacheManager.prototype.getCachedNativeRequest = function () {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest called\");\r\n        var cachedRequest = this.getTemporaryCache(TemporaryCacheKeys.NATIVE_REQUEST, true);\r\n        if (!cachedRequest) {\r\n            this.logger.trace(\"BrowserCacheManager.getCachedNativeRequest: No cached native request found\");\r\n            return null;\r\n        }\r\n        var parsedRequest = this.validateAndParseJson(cachedRequest);\r\n        if (!parsedRequest) {\r\n            this.logger.error(\"BrowserCacheManager.getCachedNativeRequest: Unable to parse native request\");\r\n            return null;\r\n        }\r\n        return parsedRequest;\r\n    };\r\n    BrowserCacheManager.prototype.isInteractionInProgress = function (matchClientId) {\r\n        var clientId = this.getInteractionInProgress();\r\n        if (matchClientId) {\r\n            return clientId === this.clientId;\r\n        }\r\n        else {\r\n            return !!clientId;\r\n        }\r\n    };\r\n    BrowserCacheManager.prototype.getInteractionInProgress = function () {\r\n        var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\r\n        return this.getTemporaryCache(key, false);\r\n    };\r\n    BrowserCacheManager.prototype.setInteractionInProgress = function (inProgress) {\r\n        // Ensure we don't overwrite interaction in progress for a different clientId\r\n        var key = Constants.CACHE_PREFIX + \".\" + TemporaryCacheKeys.INTERACTION_STATUS_KEY;\r\n        if (inProgress) {\r\n            if (this.getInteractionInProgress()) {\r\n                throw BrowserAuthError.createInteractionInProgressError();\r\n            }\r\n            else {\r\n                // No interaction is in progress\r\n                this.setTemporaryCache(key, this.clientId, false);\r\n            }\r\n        }\r\n        else if (!inProgress && this.getInteractionInProgress() === this.clientId) {\r\n            this.removeItem(key);\r\n        }\r\n    };\r\n    /**\r\n     * Returns username retrieved from ADAL or MSAL v1 idToken\r\n     */\r\n    BrowserCacheManager.prototype.getLegacyLoginHint = function () {\r\n        // Only check for adal/msal token if no SSO params are being used\r\n        var adalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n        if (adalIdTokenString) {\r\n            this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n            this.logger.verbose(\"Cached ADAL id token retrieved.\");\r\n        }\r\n        // Check for cached MSAL v1 id token\r\n        var msalIdTokenString = this.getTemporaryCache(PersistentCacheKeys.ID_TOKEN, true);\r\n        if (msalIdTokenString) {\r\n            this.removeItem(this.generateCacheKey(PersistentCacheKeys.ID_TOKEN));\r\n            this.logger.verbose(\"Cached MSAL.js v1 id token retrieved\");\r\n        }\r\n        var cachedIdTokenString = msalIdTokenString || adalIdTokenString;\r\n        if (cachedIdTokenString) {\r\n            var cachedIdToken = new IdToken(cachedIdTokenString, this.cryptoImpl);\r\n            if (cachedIdToken.claims && cachedIdToken.claims.preferred_username) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 preferred_username as loginHint\");\r\n                return cachedIdToken.claims.preferred_username;\r\n            }\r\n            else if (cachedIdToken.claims && cachedIdToken.claims.upn) {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, setting ADAL/MSAL v1 upn as loginHint\");\r\n                return cachedIdToken.claims.upn;\r\n            }\r\n            else {\r\n                this.logger.verbose(\"No SSO params used and ADAL/MSAL v1 token retrieved, however, no account hint claim found. Enable preferred_username or upn id token claim to get SSO.\");\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    /**\r\n     * Updates a credential's cache key if the current cache key is outdated\r\n     */\r\n    BrowserCacheManager.prototype.updateCredentialCacheKey = function (currentCacheKey, credential) {\r\n        var updatedCacheKey = credential.generateCredentialKey();\r\n        if (currentCacheKey !== updatedCacheKey) {\r\n            var cacheItem = this.getItem(currentCacheKey);\r\n            if (cacheItem) {\r\n                this.removeItem(currentCacheKey);\r\n                this.setItem(updatedCacheKey, cacheItem);\r\n                this.logger.verbose(\"Updated an outdated \" + credential.credentialType + \" cache key\");\r\n                return updatedCacheKey;\r\n            }\r\n            else {\r\n                this.logger.error(\"Attempted to update an outdated \" + credential.credentialType + \" cache key but no item matching the outdated key was found in storage\");\r\n            }\r\n        }\r\n        return currentCacheKey;\r\n    };\r\n    /**\r\n     * Returns application id as redirect context during AcquireTokenRedirect flow.\r\n     */\r\n    BrowserCacheManager.prototype.getRedirectRequestContext = function () {\r\n        return this.getTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, true);\r\n    };\r\n    /**\r\n     * Sets application id as the redirect context during AcquireTokenRedirect flow.\r\n     * @param value\r\n     */\r\n    BrowserCacheManager.prototype.setRedirectRequestContext = function (value) {\r\n        this.setTemporaryCache(TemporaryCacheKeys.REDIRECT_CONTEXT, value, true);\r\n    };\r\n    return BrowserCacheManager;\r\n}(CacheManager));\r\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\r\n    var cacheOptions = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        temporaryCacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false,\r\n        cacheMigrationEnabled: false\r\n    };\r\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\r\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}