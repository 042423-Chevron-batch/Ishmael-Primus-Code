{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n  // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n  let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n  // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n  if (isNode) {\n    authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n  }\n  // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n  return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n  constructor(options) {\n    var _a, _b;\n    const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n    const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix) ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}` : `${packageDetails}`;\n    const baseUri = getIdentityClientAuthorityHost(options);\n    if (!baseUri.startsWith(\"https:\")) {\n      throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n    }\n    super(Object.assign(Object.assign({\n      requestContentType: \"application/json; charset=utf-8\",\n      retryOptions: {\n        maxRetries: 3\n      }\n    }, options), {\n      userAgentOptions: {\n        userAgentPrefix\n      },\n      baseUri\n    }));\n    this.authorityHost = baseUri;\n    this.abortControllers = new Map();\n    this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n  }\n  sendTokenRequest(request, expiresOnParser) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      logger.info(`IdentityClient: sending token request to [${request.url}]`);\n      const response = yield _this.sendRequest(request);\n      expiresOnParser = expiresOnParser || (responseBody => {\n        return Date.now() + responseBody.expires_in * 1000;\n      });\n      if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n        const parsedBody = JSON.parse(response.bodyAsText);\n        if (!parsedBody.access_token) {\n          return null;\n        }\n        _this.logIdentifiers(response);\n        const token = {\n          accessToken: {\n            token: parsedBody.access_token,\n            expiresOnTimestamp: expiresOnParser(parsedBody)\n          },\n          refreshToken: parsedBody.refresh_token\n        };\n        logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n        return token;\n      } else {\n        const error = new AuthenticationError(response.status, response.bodyAsText);\n        logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n        throw error;\n      }\n    })();\n  }\n  refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options = {}) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (refreshToken === undefined) {\n        return null;\n      }\n      logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n      const refreshParams = {\n        grant_type: \"refresh_token\",\n        client_id: clientId,\n        refresh_token: refreshToken,\n        scope: scopes\n      };\n      if (clientSecret !== undefined) {\n        refreshParams.client_secret = clientSecret;\n      }\n      const query = new URLSearchParams(refreshParams);\n      return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (updatedOptions) {\n          try {\n            const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n            const request = createPipelineRequest({\n              url: `${_this2.authorityHost}/${tenantId}/${urlSuffix}`,\n              method: \"POST\",\n              body: query.toString(),\n              abortSignal: options.abortSignal,\n              headers: createHttpHeaders({\n                Accept: \"application/json\",\n                \"Content-Type\": \"application/x-www-form-urlencoded\"\n              }),\n              tracingOptions: updatedOptions.tracingOptions\n            });\n            const response = yield _this2.sendTokenRequest(request, expiresOnParser);\n            logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n            return response;\n          } catch (err) {\n            if (err.name === AuthenticationErrorName && err.errorResponse.error === \"interaction_required\") {\n              // It's likely that the refresh token has expired, so\n              // return null so that the credential implementation will\n              // initiate the authentication flow again.\n              logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n              return null;\n            } else {\n              logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n              throw err;\n            }\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  // Here is a custom layer that allows us to abort requests that go through MSAL,\n  // since MSAL doesn't allow us to pass options all the way through.\n  generateAbortSignal(correlationId) {\n    const controller = new AbortController();\n    const controllers = this.abortControllers.get(correlationId) || [];\n    controllers.push(controller);\n    this.abortControllers.set(correlationId, controllers);\n    const existingOnAbort = controller.signal.onabort;\n    controller.signal.onabort = (...params) => {\n      this.abortControllers.set(correlationId, undefined);\n      if (existingOnAbort) {\n        existingOnAbort(...params);\n      }\n    };\n    return controller.signal;\n  }\n  abortRequests(correlationId) {\n    const key = correlationId || noCorrelationId;\n    const controllers = [...(this.abortControllers.get(key) || []),\n    // MSAL passes no correlation ID to the get requests...\n    ...(this.abortControllers.get(noCorrelationId) || [])];\n    if (!controllers.length) {\n      return;\n    }\n    for (const controller of controllers) {\n      controller.abort();\n    }\n    this.abortControllers.set(key, undefined);\n  }\n  getCorrelationId(options) {\n    var _a;\n    const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map(part => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n    return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n  }\n  // The MSAL network module methods follow\n  sendGetRequestAsync(url, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"GET\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        abortSignal: _this3.generateAbortSignal(noCorrelationId)\n      });\n      const response = yield _this3.sendRequest(request);\n      _this3.logIdentifiers(response);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n  sendPostRequestAsync(url, options) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const request = createPipelineRequest({\n        url,\n        method: \"POST\",\n        body: options === null || options === void 0 ? void 0 : options.body,\n        headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n        // MSAL doesn't send the correlation ID on the get requests.\n        abortSignal: _this4.generateAbortSignal(_this4.getCorrelationId(options))\n      });\n      const response = yield _this4.sendRequest(request);\n      _this4.logIdentifiers(response);\n      return {\n        body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n        headers: response.headers.toJSON(),\n        status: response.status\n      };\n    })();\n  }\n  /**\n   * If allowLoggingAccountIdentifiers was set on the constructor options\n   * we try to log the account identifiers by parsing the received access token.\n   *\n   * The account identifiers we try to log are:\n   * - `appid`: The application or Client Identifier.\n   * - `upn`: User Principal Name.\n   *   - It might not be available in some authentication scenarios.\n   *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n   * - `tid`: Tenant Identifier.\n   * - `oid`: Object Identifier of the authenticated user.\n   */\n  logIdentifiers(response) {\n    if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n      return;\n    }\n    const unavailableUpn = \"No User Principal Name available\";\n    try {\n      const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n      const accessToken = parsed.access_token;\n      if (!accessToken) {\n        // Without an access token allowLoggingAccountIdentifiers isn't useful.\n        return;\n      }\n      const base64Metadata = accessToken.split(\".\")[1];\n      const {\n        appid,\n        upn,\n        tid,\n        oid\n      } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n      logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n    } catch (e) {\n      logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n    }\n  }\n}","map":{"version":3,"names":["ServiceClient","isNode","createHttpHeaders","createPipelineRequest","AbortController","AuthenticationError","AuthenticationErrorName","getIdentityTokenEndpointSuffix","DefaultAuthorityHost","SDK_VERSION","tracingClient","logger","noCorrelationId","getIdentityClientAuthorityHost","options","authorityHost","process","env","AZURE_AUTHORITY_HOST","IdentityClient","constructor","_a","_b","packageDetails","userAgentPrefix","userAgentOptions","baseUri","startsWith","Error","Object","assign","requestContentType","retryOptions","maxRetries","abortControllers","Map","allowLoggingAccountIdentifiers","loggingOptions","sendTokenRequest","request","expiresOnParser","_this","_asyncToGenerator","info","url","response","sendRequest","responseBody","Date","now","expires_in","bodyAsText","status","parsedBody","JSON","parse","access_token","logIdentifiers","token","accessToken","expiresOnTimestamp","refreshToken","refresh_token","error","warning","errorResponse","errorDescription","refreshAccessToken","tenantId","clientId","scopes","clientSecret","_this2","undefined","refreshParams","grant_type","client_id","scope","client_secret","query","URLSearchParams","withSpan","_ref","updatedOptions","urlSuffix","method","body","toString","abortSignal","headers","Accept","tracingOptions","err","name","_x","apply","arguments","generateAbortSignal","correlationId","controller","controllers","get","push","set","existingOnAbort","signal","onabort","params","abortRequests","key","length","abort","getCorrelationId","parameter","split","map","part","find","sendGetRequestAsync","_this3","toJSON","sendPostRequestAsync","_this4","unavailableUpn","parsed","base64Metadata","appid","upn","tid","oid","Buffer","from","e","message"],"sources":["C:/Users/ishma/Revature/Ishmael-Primus-Code-/ecomm-prj1/node_modules/@azure/identity/dist-esm/src/client/identityClient.js"],"sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ServiceClient } from \"@azure/core-client\";\nimport { isNode } from \"@azure/core-util\";\nimport { createHttpHeaders, createPipelineRequest, } from \"@azure/core-rest-pipeline\";\nimport { AbortController } from \"@azure/abort-controller\";\nimport { AuthenticationError, AuthenticationErrorName } from \"../errors\";\nimport { getIdentityTokenEndpointSuffix } from \"../util/identityTokenEndpoint\";\nimport { DefaultAuthorityHost, SDK_VERSION } from \"../constants\";\nimport { tracingClient } from \"../util/tracing\";\nimport { logger } from \"../util/logging\";\nconst noCorrelationId = \"noCorrelationId\";\n/**\n * @internal\n */\nexport function getIdentityClientAuthorityHost(options) {\n    // The authorityHost can come from options or from the AZURE_AUTHORITY_HOST environment variable.\n    let authorityHost = options === null || options === void 0 ? void 0 : options.authorityHost;\n    // The AZURE_AUTHORITY_HOST environment variable can only be provided in Node.js.\n    if (isNode) {\n        authorityHost = authorityHost !== null && authorityHost !== void 0 ? authorityHost : process.env.AZURE_AUTHORITY_HOST;\n    }\n    // If the authorityHost is not provided, we use the default one from the public cloud: https://login.microsoftonline.com\n    return authorityHost !== null && authorityHost !== void 0 ? authorityHost : DefaultAuthorityHost;\n}\n/**\n * The network module used by the Identity credentials.\n *\n * It allows for credentials to abort any pending request independently of the MSAL flow,\n * by calling to the `abortRequests()` method.\n *\n */\nexport class IdentityClient extends ServiceClient {\n    constructor(options) {\n        var _a, _b;\n        const packageDetails = `azsdk-js-identity/${SDK_VERSION}`;\n        const userAgentPrefix = ((_a = options === null || options === void 0 ? void 0 : options.userAgentOptions) === null || _a === void 0 ? void 0 : _a.userAgentPrefix)\n            ? `${options.userAgentOptions.userAgentPrefix} ${packageDetails}`\n            : `${packageDetails}`;\n        const baseUri = getIdentityClientAuthorityHost(options);\n        if (!baseUri.startsWith(\"https:\")) {\n            throw new Error(\"The authorityHost address must use the 'https' protocol.\");\n        }\n        super(Object.assign(Object.assign({ requestContentType: \"application/json; charset=utf-8\", retryOptions: {\n                maxRetries: 3,\n            } }, options), { userAgentOptions: {\n                userAgentPrefix,\n            }, baseUri }));\n        this.authorityHost = baseUri;\n        this.abortControllers = new Map();\n        this.allowLoggingAccountIdentifiers = (_b = options === null || options === void 0 ? void 0 : options.loggingOptions) === null || _b === void 0 ? void 0 : _b.allowLoggingAccountIdentifiers;\n    }\n    async sendTokenRequest(request, expiresOnParser) {\n        logger.info(`IdentityClient: sending token request to [${request.url}]`);\n        const response = await this.sendRequest(request);\n        expiresOnParser =\n            expiresOnParser ||\n                ((responseBody) => {\n                    return Date.now() + responseBody.expires_in * 1000;\n                });\n        if (response.bodyAsText && (response.status === 200 || response.status === 201)) {\n            const parsedBody = JSON.parse(response.bodyAsText);\n            if (!parsedBody.access_token) {\n                return null;\n            }\n            this.logIdentifiers(response);\n            const token = {\n                accessToken: {\n                    token: parsedBody.access_token,\n                    expiresOnTimestamp: expiresOnParser(parsedBody),\n                },\n                refreshToken: parsedBody.refresh_token,\n            };\n            logger.info(`IdentityClient: [${request.url}] token acquired, expires on ${token.accessToken.expiresOnTimestamp}`);\n            return token;\n        }\n        else {\n            const error = new AuthenticationError(response.status, response.bodyAsText);\n            logger.warning(`IdentityClient: authentication error. HTTP status: ${response.status}, ${error.errorResponse.errorDescription}`);\n            throw error;\n        }\n    }\n    async refreshAccessToken(tenantId, clientId, scopes, refreshToken, clientSecret, expiresOnParser, options = {}) {\n        if (refreshToken === undefined) {\n            return null;\n        }\n        logger.info(`IdentityClient: refreshing access token with client ID: ${clientId}, scopes: ${scopes} started`);\n        const refreshParams = {\n            grant_type: \"refresh_token\",\n            client_id: clientId,\n            refresh_token: refreshToken,\n            scope: scopes,\n        };\n        if (clientSecret !== undefined) {\n            refreshParams.client_secret = clientSecret;\n        }\n        const query = new URLSearchParams(refreshParams);\n        return tracingClient.withSpan(\"IdentityClient.refreshAccessToken\", options, async (updatedOptions) => {\n            try {\n                const urlSuffix = getIdentityTokenEndpointSuffix(tenantId);\n                const request = createPipelineRequest({\n                    url: `${this.authorityHost}/${tenantId}/${urlSuffix}`,\n                    method: \"POST\",\n                    body: query.toString(),\n                    abortSignal: options.abortSignal,\n                    headers: createHttpHeaders({\n                        Accept: \"application/json\",\n                        \"Content-Type\": \"application/x-www-form-urlencoded\",\n                    }),\n                    tracingOptions: updatedOptions.tracingOptions,\n                });\n                const response = await this.sendTokenRequest(request, expiresOnParser);\n                logger.info(`IdentityClient: refreshed token for client ID: ${clientId}`);\n                return response;\n            }\n            catch (err) {\n                if (err.name === AuthenticationErrorName &&\n                    err.errorResponse.error === \"interaction_required\") {\n                    // It's likely that the refresh token has expired, so\n                    // return null so that the credential implementation will\n                    // initiate the authentication flow again.\n                    logger.info(`IdentityClient: interaction required for client ID: ${clientId}`);\n                    return null;\n                }\n                else {\n                    logger.warning(`IdentityClient: failed refreshing token for client ID: ${clientId}: ${err}`);\n                    throw err;\n                }\n            }\n        });\n    }\n    // Here is a custom layer that allows us to abort requests that go through MSAL,\n    // since MSAL doesn't allow us to pass options all the way through.\n    generateAbortSignal(correlationId) {\n        const controller = new AbortController();\n        const controllers = this.abortControllers.get(correlationId) || [];\n        controllers.push(controller);\n        this.abortControllers.set(correlationId, controllers);\n        const existingOnAbort = controller.signal.onabort;\n        controller.signal.onabort = (...params) => {\n            this.abortControllers.set(correlationId, undefined);\n            if (existingOnAbort) {\n                existingOnAbort(...params);\n            }\n        };\n        return controller.signal;\n    }\n    abortRequests(correlationId) {\n        const key = correlationId || noCorrelationId;\n        const controllers = [\n            ...(this.abortControllers.get(key) || []),\n            // MSAL passes no correlation ID to the get requests...\n            ...(this.abortControllers.get(noCorrelationId) || []),\n        ];\n        if (!controllers.length) {\n            return;\n        }\n        for (const controller of controllers) {\n            controller.abort();\n        }\n        this.abortControllers.set(key, undefined);\n    }\n    getCorrelationId(options) {\n        var _a;\n        const parameter = (_a = options === null || options === void 0 ? void 0 : options.body) === null || _a === void 0 ? void 0 : _a.split(\"&\").map((part) => part.split(\"=\")).find(([key]) => key === \"client-request-id\");\n        return parameter && parameter.length ? parameter[1] || noCorrelationId : noCorrelationId;\n    }\n    // The MSAL network module methods follow\n    async sendGetRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"GET\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            abortSignal: this.generateAbortSignal(noCorrelationId),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    async sendPostRequestAsync(url, options) {\n        const request = createPipelineRequest({\n            url,\n            method: \"POST\",\n            body: options === null || options === void 0 ? void 0 : options.body,\n            headers: createHttpHeaders(options === null || options === void 0 ? void 0 : options.headers),\n            // MSAL doesn't send the correlation ID on the get requests.\n            abortSignal: this.generateAbortSignal(this.getCorrelationId(options)),\n        });\n        const response = await this.sendRequest(request);\n        this.logIdentifiers(response);\n        return {\n            body: response.bodyAsText ? JSON.parse(response.bodyAsText) : undefined,\n            headers: response.headers.toJSON(),\n            status: response.status,\n        };\n    }\n    /**\n     * If allowLoggingAccountIdentifiers was set on the constructor options\n     * we try to log the account identifiers by parsing the received access token.\n     *\n     * The account identifiers we try to log are:\n     * - `appid`: The application or Client Identifier.\n     * - `upn`: User Principal Name.\n     *   - It might not be available in some authentication scenarios.\n     *   - If it's not available, we put a placeholder: \"No User Principal Name available\".\n     * - `tid`: Tenant Identifier.\n     * - `oid`: Object Identifier of the authenticated user.\n     */\n    logIdentifiers(response) {\n        if (!this.allowLoggingAccountIdentifiers || !response.bodyAsText) {\n            return;\n        }\n        const unavailableUpn = \"No User Principal Name available\";\n        try {\n            const parsed = response.parsedBody || JSON.parse(response.bodyAsText);\n            const accessToken = parsed.access_token;\n            if (!accessToken) {\n                // Without an access token allowLoggingAccountIdentifiers isn't useful.\n                return;\n            }\n            const base64Metadata = accessToken.split(\".\")[1];\n            const { appid, upn, tid, oid } = JSON.parse(Buffer.from(base64Metadata, \"base64\").toString(\"utf8\"));\n            logger.info(`[Authenticated account] Client ID: ${appid}. Tenant ID: ${tid}. User Principal Name: ${upn || unavailableUpn}. Object ID (user): ${oid}`);\n        }\n        catch (e) {\n            logger.warning(\"allowLoggingAccountIdentifiers was set, but we couldn't log the account information. Error:\", e.message);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}